{{ define "main" }}
<section class="section">
  <div class="section-narrow xtrending-shell">
    <header class="page-header xtrending-hero">
      <p class="page-eyebrow">{{ i18n "xtrending_eyebrow" }}</p>
      <h1>{{ .Title }}</h1>
      {{ with .Description }}
        <p class="page-desc">{{ . }}</p>
      {{ end }}
    </header>

    <div class="xtrending-actions">
      <div class="xtrending-search">
        <input type="search" id="xtrending-search" placeholder="{{ i18n "xtrending_search_placeholder" }}" aria-label="{{ i18n "xtrending_search_aria" }}">
      </div>
      <div class="xtrending-filter-row" aria-label="{{ i18n "xtrending_filter_aria" }}">
        <div id="xtrending-tag-filters" class="xtrending-pills"></div>
      </div>
    </div>

    <div id="xtrending-grid" class="xtrending-grid" aria-live="polite"></div>
    <div id="xtrending-empty" class="xtrending-empty" hidden>
      <p>{{ i18n "xtrending_empty_title" }}</p>
      <p>{{ i18n "xtrending_empty_hint" }}</p>
    </div>
    <div id="xtrending-empty-filter" class="xtrending-empty" hidden>
      <p>{{ i18n "xtrending_empty_filter_title" }}</p>
      <p>{{ i18n "xtrending_empty_filter_hint" }}</p>
    </div>
  </div>
</section>

<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<script>
(() => {
  const dataUrl = "{{ "/x-trending.json" | relLangURL }}";
  const TWITTER_THEME = "dark";
  const SEARCH_DEBOUNCE_MS = 250;
  const EMBED_ROOT_MARGIN = "700px 0px";

  // 标签折叠配置
  const MAX_TAGS_VISIBLE = 8;
  let filtersCollapsed = true;

  const I18N = {
    all: "{{ i18n "xtrending_all" }}",
    expandTags: "{{ i18n "xtrending_expand_tags" | default (cond (eq .Site.LanguageCode "zh-CN") "展开更多 (+{count})" "Show more (+{count})") }}",
    collapseTags: "{{ i18n "xtrending_collapse_tags" | default (cond (eq .Site.LanguageCode "zh-CN") "收起" "Collapse") }}"
  };

  const grid = document.getElementById("xtrending-grid");
  const empty = document.getElementById("xtrending-empty");
  const filterEmpty = document.getElementById("xtrending-empty-filter");
  const searchInput = document.getElementById("xtrending-search");
  const tagFiltersWrap = document.getElementById("xtrending-tag-filters");

  let allItems = [];
  let currentTag = "all";
  let searchTerm = "";
  let cardRecords = [];
  let twitterReadyPromise = null;

  function setEmpty(show) { if (empty) empty.hidden = !show; }
  function setFilterEmpty(show) { if (filterEmpty) filterEmpty.hidden = !show; }

  // 从 URL 中提取推文 ID
  function parseTweetId(url) {
    if (!url) return null;
    const patterns = [
      /(twitter|x)\.com\/.+\/status\/(\d+)/i,
      /(twitter|x)\.com\/i\/status\/(\d+)/i
    ];
    for (const re of patterns) {
      const m = url.match(re);
      if (m && m[2]) return m[2];
    }
    const anyDigits = url.match(/\d{10,}/);
    return anyDigits ? anyDigits[0] : null;
  }

  function collectTags(items) {
    const tags = new Set();
    items.forEach((item) => {
      const arr = Array.isArray(item.tags) ? item.tags : [];
      arr.forEach((t) => { if (t) tags.add(t.toString().trim()); });
    });
    return Array.from(tags).filter(Boolean);
  }

  function collectTagCounts(items) {
    const counts = Object.create(null);
    items.forEach((item) => {
      const arr = Array.isArray(item.tags) ? item.tags : [];
      const uniq = new Set(arr.map((t) => (t || "").toString().trim()).filter(Boolean));
      uniq.forEach((t) => { counts[t] = (counts[t] || 0) + 1; });
    });
    return counts;
  }

  function ensureTwitterReady() {
    if (twitterReadyPromise) return twitterReadyPromise;
    twitterReadyPromise = new Promise((resolve) => {
      if (window.twttr && window.twttr.widgets) {
        resolve(window.twttr);
        return;
      }
      window.twttr = window.twttr || {};
      window.twttr.ready = window.twttr.ready || function(fn) {
        if (window.twttr.widgets) fn(window.twttr);
        else (window.twttr._e = window.twttr._e || []).push(fn);
      };
      window.twttr.ready(() => resolve(window.twttr));
    });
    return twitterReadyPromise;
  }

  const embedObserver = ("IntersectionObserver" in window)
    ? new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) return;
        const card = entry.target;
        if (!card || card.hidden) return;
        queueEmbed(card);
      });
    }, { rootMargin: EMBED_ROOT_MARGIN, threshold: 0.01 })
    : null;

  function queueEmbed(card) {
    if (!card || card.hidden) return;
    const state = card.dataset.embedState || "idle";
    if (state === "loaded" || state === "loading" || state === "queued" || state === "failed") return;
    card.dataset.embedState = "queued";
    ensureTwitterReady().then(() => embedTweet(card));
  }

  function embedTweet(card) {
    if (!card || card.hidden) return;
    const state = card.dataset.embedState || "idle";
    if (state === "loaded" || state === "loading" || state === "failed") return;

    const tweetId = card.dataset.tweetId;
    if (!tweetId) {
      card.dataset.embedState = "failed";
      return;
    }

    const embedWrap = card.querySelector(".xtrending-embed");
    if (!embedWrap) {
      card.dataset.embedState = "failed";
      return;
    }

    if (!(window.twttr && window.twttr.widgets && window.twttr.widgets.createTweet)) {
      // widgets.js 可能还没真正可用，保持 queued 等待下一次触发
      card.dataset.embedState = "queued";
      return;
    }

    card.dataset.embedState = "loading";
    embedWrap.hidden = false;
    embedWrap.innerHTML = "";

    window.twttr.widgets.createTweet(tweetId, embedWrap, {
      theme: TWITTER_THEME,
      dnt: true,
      align: "center"
    }).then(() => {
      card.dataset.embedState = "loaded";
      const skeleton = card.querySelector(".xtrending-skeleton");
      if (skeleton) skeleton.classList.add("is-hidden");
      if (embedObserver) embedObserver.unobserve(card);
    }).catch(() => {
      card.dataset.embedState = "failed";
      embedWrap.hidden = true;
      const skeleton = card.querySelector(".xtrending-skeleton");
      if (skeleton) skeleton.classList.add("is-failed");
    });
  }

  function renderTagPills(tags) {
    if (!tagFiltersWrap) return;
    tagFiltersWrap.innerHTML = "";

    const visibleTags = (() => {
      if (!filtersCollapsed) return tags;
      const base = tags.slice(0, MAX_TAGS_VISIBLE);
      if (currentTag !== "all" && tags.includes(currentTag) && !base.includes(currentTag)) {
        base.push(currentTag);
      }
      return base;
    })();

    const frag = document.createDocumentFragment();
    const currentTagLower = (currentTag || "all").toString().trim().toLowerCase();

    const allBtn = document.createElement("button");
    allBtn.className = "xtrending-filter-pill" + (currentTagLower === "all" ? " active" : "");
    allBtn.textContent = I18N.all;
    allBtn.dataset.tag = "all";
    frag.appendChild(allBtn);

    const counts = collectTagCounts(allItems);
    visibleTags.forEach((tag) => {
      const btn = document.createElement("button");
      const isActive = currentTagLower !== "all" && currentTagLower === (tag || "").toString().trim().toLowerCase();
      btn.className = "xtrending-filter-pill" + (isActive ? " active" : "");
      btn.textContent = `${tag} @${counts[tag] || 0}`;
      btn.dataset.tag = tag;
      frag.appendChild(btn);
    });

    if (tags.length > MAX_TAGS_VISIBLE) {
      const toggle = document.createElement("button");
      toggle.className = "xtrending-filter-toggle";
      toggle.type = "button";
      const more = tags.length - MAX_TAGS_VISIBLE;
      toggle.textContent = filtersCollapsed
        ? I18N.expandTags.replace("{count}", String(more))
        : I18N.collapseTags;
      toggle.addEventListener("click", () => {
        filtersCollapsed = !filtersCollapsed;
        renderTagPills(tags);
      });
      frag.appendChild(toggle);
    }

    tagFiltersWrap.appendChild(frag);

    tagFiltersWrap.querySelectorAll("button[data-tag]").forEach((btn) => {
      btn.addEventListener("click", () => {
        currentTag = btn.dataset.tag || "all";
        tagFiltersWrap.querySelectorAll("button[data-tag]").forEach((el) => el.classList.remove("active"));
        btn.classList.add("active");
        applyFilter();
      });
    });
  }

  function buildCard(item) {
    if (!item) return null;
    const tweetId = parseTweetId(item.originalUrl);
    if (!tweetId) return null;

    const card = document.createElement("article");
    card.className = "xtrending-card reveal-text";
    card.dataset.tweetId = tweetId;
    card.dataset.embedState = "idle";

    const skeleton = document.createElement("div");
    skeleton.className = "xtrending-skeleton";
    card.appendChild(skeleton);

    // 创建嵌入容器（进入可视区后再 createTweet）
    const embedWrap = document.createElement("div");
    embedWrap.className = "xtrending-embed";
    embedWrap.hidden = true;
    card.appendChild(embedWrap);

    if (embedObserver) embedObserver.observe(card);
    requestAnimationFrame(() => card.classList.add("active"));

    return { card, item };
  }

  function renderGridOnce(items) {
    if (!grid) return;
    grid.innerHTML = "";

    cardRecords = [];

    const frag = document.createDocumentFragment();
    items.forEach((item) => {
      const built = buildCard(item);
      if (!built) return;
      cardRecords.push(built);
      frag.appendChild(built.card);
    });
    grid.appendChild(frag);

    // 兼容不支持 IntersectionObserver 的环境：直接创建所有嵌入
    if (!embedObserver) {
      ensureTwitterReady().then(() => {
        cardRecords.forEach((rec) => {
          if (!rec.card.hidden) {
            rec.card.dataset.embedState = "queued";
            embedTweet(rec.card);
          }
        });
      });
    }
  }

  function debounce(fn, delayMs) {
    let timer = null;
    return (...args) => {
      if (timer) window.clearTimeout(timer);
      timer = window.setTimeout(() => fn(...args), delayMs);
    };
  }

  function applyFilter() {
    if (!cardRecords.length) return;
    const term = searchTerm.trim().toLowerCase();
    let visibleCount = 0;

    const matchesSearch = (item) => {
      if (!term) return true;
      const hay = [
        item.title,
        item.description,
        item.author_name,
        item.author_handle,
        item.date,
        ...(Array.isArray(item.tags) ? item.tags : [])
      ].map((v) => (v || "").toString().toLowerCase()).join(" ");
      return hay.includes(term);
    };

    const byTag = (item) => {
      if (currentTag === "all") return true;
      const tags = Array.isArray(item.tags) ? item.tags : [];
      return tags.some((t) => (t || "").toString().trim().toLowerCase() === currentTag.toLowerCase());
    };

    cardRecords.forEach((rec) => {
      const show = matchesSearch(rec.item) && byTag(rec.item);
      rec.card.hidden = !show;
      if (show) visibleCount += 1;
    });

    const noMatch = visibleCount === 0;
    setFilterEmpty(noMatch && (currentTag !== "all" || term));

    // 如果筛选后有内容且支持 IO，确保可视区内的卡片能触发 embed
    if (embedObserver && visibleCount > 0) {
      requestAnimationFrame(() => {
        cardRecords.forEach((rec) => {
          if (rec.card.hidden) return;
          // 触发一次观察回调（某些情况下从 hidden -> visible 不会立刻触发）
          embedObserver.observe(rec.card);
        });
      });
    }
  }

  function render(items) {
    if (!items || !items.length) {
      setEmpty(true);
      return;
    }
    setEmpty(false);
    allItems = items;
    renderTagPills(collectTags(allItems));
    setFilterEmpty(false);

    renderGridOnce(allItems);
    applyFilter();
  }

  if (searchInput) {
    const onSearch = debounce((value) => {
      searchTerm = value || "";
      applyFilter();
    }, SEARCH_DEBOUNCE_MS);

    searchInput.addEventListener("input", (event) => {
      onSearch(event.target.value);
    });
  }

  fetch(dataUrl)
    .then((res) => { if (!res.ok) throw new Error("网络异常"); return res.json(); })
    .then((items) => render(items))
    .catch(() => setEmpty(true));
})();
</script>

<style>
.xtrending-shell {
  padding-bottom: 5rem;
}

.xtrending-hero {
  text-align: center;
  margin-bottom: 2.5rem;
}

.xtrending-hero h1 {
  margin: 0.35rem 0;
  font-size: 2.8rem;
  font-family: "Cormorant Garamond", serif;
  font-weight: 300;
  letter-spacing: -0.01em;
}

.xtrending-actions {
  display: flex;
  flex-direction: column;
  gap: 0.8rem;
  margin: 1rem 0 2rem;
}

.xtrending-search {
  width: 100%;
  max-width: 500px;
  margin: 0 auto;
}

.xtrending-search input {
  width: 100%;
  padding: 0.7rem 1rem;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: var(--surface-highlight);
  color: var(--text-main);
  font-size: 0.95rem;
  outline: none;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

.xtrending-search input:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.2);
}

.xtrending-filter-row {
  display: flex;
  flex-wrap: wrap;
  gap: 0.6rem;
  margin: 0.2rem 0 0.8rem;
  justify-content: center;
}

.xtrending-pills {
  display: flex;
  flex-wrap: wrap;
  gap: 0.6rem;
  justify-content: center;
}

.xtrending-filter-pill {
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--text-main);
  padding: 0.35rem 0.9rem;
  border-radius: 999px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
}

.xtrending-filter-pill:hover {
  border-color: var(--accent);
}

.xtrending-filter-pill.active {
  background: var(--accent);
  color: #000;
  border-color: var(--accent);
}

.xtrending-filter-toggle {
  border: 1px dashed var(--border);
  background: var(--surface-highlight);
  color: var(--text-muted);
  padding: 0.35rem 0.9rem;
  border-radius: 999px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: color 0.2s ease, border-color 0.2s ease;
}

.xtrending-filter-toggle:hover {
  color: var(--accent);
  border-color: var(--accent);
}

/* 瀑布流布局 */
.xtrending-grid {
  column-gap: 1.25rem;
  column-width: 350px;
}

.xtrending-card {
  display: inline-block;
  width: 100%;
  margin: 0 0 1.25rem;
  background: var(--surface-highlight);
  border: 1px solid var(--border);
  border-radius: 0;
  overflow: hidden;
  break-inside: avoid;
  -webkit-column-break-inside: avoid;
  page-break-inside: avoid;
  position: relative;
}

.xtrending-card[data-embed-state="idle"],
.xtrending-card[data-embed-state="queued"],
.xtrending-card[data-embed-state="loading"] {
  min-height: 420px;
}

/* 推文嵌入容器 */
.xtrending-embed {
  position: relative;
  z-index: 1;
}

.xtrending-skeleton.is-hidden {
  display: none;
}

.xtrending-skeleton {
  position: absolute;
  inset: 0;
  z-index: 2;
  background: var(--surface-highlight);
}

.xtrending-skeleton::before {
  content: "";
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg,
    rgba(255,255,255,0.03) 0%,
    rgba(255,255,255,0.09) 45%,
    rgba(255,255,255,0.03) 100%);
  transform: translateX(-60%);
  animation: xtrendingShimmer 1.4s ease-in-out infinite;
}

.xtrending-skeleton.is-failed::before {
  display: none;
}

@keyframes xtrendingShimmer {
  0% { transform: translateX(-60%); }
  100% { transform: translateX(60%); }
}

/* Twitter 嵌入推文样式覆盖 */
.xtrending-embed .twitter-tweet {
  margin: 0 !important;
}

.xtrending-embed .twitter-tweet-rendered {
  margin: 0 !important;
}

/* Twitter iframe 宽度适配 */
.xtrending-embed iframe {
  max-width: 100% !important;
}

.xtrending-empty {
  margin-top: 2rem;
  text-align: center;
  padding: 2rem;
  border: 1px solid var(--border);
  background: var(--surface-highlight);
  color: var(--text-muted);
}

/* 渐入动画 */
.reveal-text {
  opacity: 0;
  transform: translateY(20px);
  transition: opacity 0.5s ease, transform 0.5s ease;
}

.reveal-text.active {
  opacity: 1;
  transform: translateY(0);
}

/* 响应式 */
@media (max-width: 768px) {
  .xtrending-grid {
    column-width: 100%;
    column-count: 1;
  }
}
</style>
{{ end }}
