<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>体素上海 | Voxel Shanghai</title>
  <style>
    :root {
      --bg-sky-top: #0d1a3a;
      --bg-sky-mid: #102b73;
      --bg-sky-bottom: #0d3c7a;
      --water-top: rgba(26, 102, 173, 0.75);
      --water-bottom: rgba(15, 56, 120, 0.92);
      --accent-1: #ff3d6f;
      --accent-2: #ffd166;
      --accent-3: #63ffd8;
      --accent-4: #9b7bff;
      --text: #e9f1ff;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body, html {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at 30% 10%, rgba(255,255,255,0.08), transparent 35%),
                  linear-gradient(180deg, var(--bg-sky-top), var(--bg-sky-mid) 55%, var(--bg-sky-bottom));
      color: var(--text);
      font-family: "Avenir Next", "SF Pro Display", "Segoe UI", "Helvetica Neue", sans-serif;
    }
    #canvas {
      position: absolute;
      inset: 0;
    }
    .ui {
      position: absolute;
      top: 24px;
      left: 24px;
      padding: 14px 18px;
      background: rgba(6, 10, 24, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.35);
      max-width: 360px;
    }
    .ui h1 {
      font-size: 20px;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }
    .ui p {
      font-size: 13px;
      line-height: 1.5;
      color: rgba(233, 241, 255, 0.8);
    }
    .pulse {
      height: 6px;
      width: 72px;
      background: linear-gradient(90deg, var(--accent-1), var(--accent-2), var(--accent-3), var(--accent-4));
      border-radius: 999px;
      margin-top: 10px;
      position: relative;
      overflow: hidden;
    }
    .pulse::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,0.8), rgba(255,255,255,0));
      animation: sweep 2.8s linear infinite;
    }
    @keyframes sweep {
      from { transform: translateX(-100%); }
      to { transform: translateX(100%); }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="ui">
    <h1>体素上海 · 夜景</h1>
    <p>东方明珠、上海中心、金茂、外滩与黄浦江被彩色体素拼接。拖动/缩放浏览，画面会有呼吸灯与漂浮立方。</p>
    <div class="pulse"></div>
  </div>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let w = innerWidth, h = innerHeight;
    canvas.width = w; canvas.height = h;

    const unit = 18; // 体素尺寸
    const cubes = [];
    const floaters = [];
    let offsetX = 0, offsetY = 0, zoom = 1;

    const palette = [
      "#ff4f8b", "#ffda6b", "#7cf2d6", "#8c7bff", "#5dd4ff",
      "#ff7b3f", "#ffd4f7", "#6eff78", "#ffc857", "#73a1ff"
    ];

    function resize() {
      w = innerWidth; h = innerHeight;
      canvas.width = w; canvas.height = h;
    }
    addEventListener("resize", resize);

    function shadeColor(hex, amt) {
      const num = parseInt(hex.slice(1), 16);
      let r = (num >> 16) + amt;
      let g = ((num >> 8) & 0x00FF) + amt;
      let b = (num & 0x0000FF) + amt;
      r = Math.max(0, Math.min(255, r));
      g = Math.max(0, Math.min(255, g));
      b = Math.max(0, Math.min(255, b));
      return "#" + (b | (g << 8) | (r << 16)).toString(16).padStart(6, "0");
    }

    function isoProject(x, y, z) {
      const isoX = (x - y) * unit * 0.82;
      const isoY = (x + y) * unit * 0.41 - z * unit;
      return {
        x: isoX * zoom + w / 2 + offsetX,
        y: isoY * zoom + h * 0.68 + offsetY
      };
    }

    function drawFace(points, fill, stroke = "rgba(0,0,0,0.1)") {
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
      ctx.closePath();
      ctx.fillStyle = fill;
      ctx.fill();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 0.4;
      ctx.stroke();
    }

    function drawCube(c) {
      const { x, y, z, color } = c;
      const pTop = isoProject(x, y, z + 1);
      const pTopX2 = isoProject(x + 1, y, z + 1);
      const pTopY2 = isoProject(x, y + 1, z + 1);
      const pTopXY = isoProject(x + 1, y + 1, z + 1);
      const pBase = isoProject(x, y, z);
      const pBaseX2 = isoProject(x + 1, y, z);
      const pBaseY2 = isoProject(x, y + 1, z);
      const pBaseXY = isoProject(x + 1, y + 1, z);

      // top
      drawFace([pTop, pTopX2, pTopXY, pTopY2], shadeColor(color, 28));
      // left
      drawFace([pTop, pTopY2, pBaseY2, pBase], shadeColor(color, -5));
      // right
      drawFace([pTop, pTopX2, pBaseX2, pBase], shadeColor(color, -20));
    }

    function addRectPrism(x0, y0, z0, w, d, h, color) {
      for (let x = x0; x < x0 + w; x++) {
        for (let y = y0; y < y0 + d; y++) {
          for (let z = z0; z < z0 + h; z++) {
            cubes.push({ x, y, z, color });
          }
        }
      }
    }

    function buildPearl(x, y) {
      addRectPrism(x, y, 0, 2, 2, 5, "#a5b3ff");
      addRectPrism(x, y, 5, 3, 3, 4, "#ff4f8b");
      addRectPrism(x, y, 9, 2, 2, 5, "#ffc857");
      addRectPrism(x - 1, y - 1, 14, 5, 5, 3, "#ff6fcf");
      addRectPrism(x, y, 17, 2, 2, 9, "#9b7bff");
      addRectPrism(x - 1, y - 1, 26, 4, 4, 3, "#63ffd8");
      addRectPrism(x, y, 29, 2, 2, 5, "#f4e3ff");
    }

    function buildJinMao(x, y) {
      let height = 20;
      for (let i = 0; i < 5; i++) {
        addRectPrism(x - i, y - i, i * 3, 6 + i, 6 + i, 3, "#5dd4ff");
        height += 3;
      }
      addRectPrism(x + 1, y + 1, height, 2, 2, 6, "#ffd166");
    }

    function buildShanghaiTower(x, y) {
      for (let z = 0; z < 40; z++) {
        const twist = Math.sin(z * 0.15) * 1.3;
        addRectPrism(x + Math.floor(twist), y - Math.floor(twist), z, 4, 4, 1, z % 5 === 0 ? "#63ffd8" : "#7cf2d6");
        if (z % 6 === 0) addRectPrism(x + 1, y + 1, z, 2, 2, 1, "#ffd4f7");
      }
      addRectPrism(x + 1, y + 1, 40, 2, 2, 5, "#ff3d6f");
    }

    function buildIFC(x, y) {
      addRectPrism(x, y, 0, 5, 5, 24, "#5dd4ff");
      for (let z = 0; z < 24; z += 3) addRectPrism(x + 1, y + 1, z + 1, 3, 3, 1, "#ffd166");
      addRectPrism(x + 2, y + 2, 24, 1, 1, 8, "#ff7b3f");
    }

    function buildBund(startX, startY) {
      for (let i = 0; i < 12; i++) {
        const h = 4 + (i % 3) * 2;
        addRectPrism(startX + i * 3, startY + (i % 2), 0, 3, 3, h, palette[(i * 2) % palette.length]);
        addRectPrism(startX + i * 3, startY + (i % 2), h, 3, 3, 1, "#ffd166");
      }
    }

    function buildRiverBoats() {
      for (let i = 0; i < 4; i++) {
        const bx = -18 + i * 12;
        const by = 24 + i * 2;
        addRectPrism(bx, by, -1, 3, 6, 1, "#63ffd8");
        addRectPrism(bx + 1, by + 2, 0, 1, 2, 1, "#ff4f8b");
      }
    }

    function buildSkyline() {
      buildPearl(4, 6);
      buildShanghaiTower(-2, 2);
      buildJinMao(10, -4);
      buildIFC(-12, 8);
      buildBund(-30, 20);
      buildBund(10, 18);
      buildRiverBoats();
      for (let i = 0; i < 18; i++) {
        const x = -25 + i * 3;
        const y = -16 + (i % 4);
        const h = 6 + (i % 5) * 3;
        addRectPrism(x, y, 0, 3, 3, h, palette[(i + 1) % palette.length]);
      }
      // elevated skyway
      for (let i = 0; i < 16; i++) {
        addRectPrism(-20 + i, -8 + Math.sin(i * 0.3), 10, 1, 1, 1, "#ffc857");
      }
    }

    function createFloaters() {
      for (let i = 0; i < 12; i++) {
        floaters.push({
          x: -30 + Math.random() * 60,
          y: -24 + Math.random() * 26,
          z: 12 + Math.random() * 14,
          color: palette[i % palette.length],
          speed: 0.004 + Math.random() * 0.006,
          offset: Math.random() * Math.PI * 2
        });
      }
    }

    function drawFloaters(time) {
      for (const f of floaters) {
        const pulse = Math.sin(time * f.speed + f.offset);
        const proj = isoProject(f.x, f.y, f.z + pulse * 0.8);
        const size = 6 + pulse * 2;
        ctx.fillStyle = f.color;
        ctx.globalAlpha = 0.8;
        ctx.fillRect(proj.x - size / 2, proj.y - size / 2, size, size);
        ctx.globalAlpha = 1;
      }
    }

    function drawWater() {
      const grd = ctx.createLinearGradient(0, h * 0.65, 0, h);
      grd.addColorStop(0, "rgba(70, 160, 255, 0.55)");
      grd.addColorStop(1, "rgba(14, 46, 120, 0.9)");
      ctx.fillStyle = grd;
      ctx.fillRect(0, h * 0.65, w, h * 0.4);
      ctx.fillStyle = "rgba(255,255,255,0.05)";
      for (let i = 0; i < 30; i++) {
        const y = h * 0.68 + i * 12;
        ctx.fillRect((i * 73) % w, y, 120, 2);
      }
    }

    function prepareScene() {
      cubes.length = 0;
      buildSkyline();
      cubes.sort((a, b) => (a.x + a.y + a.z) - (b.x + b.y + b.z));
    }

    function drawScene(time) {
      ctx.clearRect(0, 0, w, h);
      const grad = ctx.createLinearGradient(0, 0, 0, h);
      grad.addColorStop(0, "#0a1030");
      grad.addColorStop(0.45, "#0f2d70");
      grad.addColorStop(1, "#0c3b78");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);
      drawWater();

      for (const c of cubes) drawCube(c);
      drawFloaters(time);
      drawStars(time);
    }

    const stars = Array.from({ length: 120 }, () => ({
      x: Math.random() * 1,
      y: Math.random() * 0.45,
      s: Math.random() * 2 + 0.5,
      p: Math.random() * Math.PI * 2
    }));

    function drawStars(t) {
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      for (const s of stars) {
        const alpha = 0.4 + 0.6 * Math.sin(t * 0.001 + s.p);
        ctx.globalAlpha = alpha;
        ctx.fillRect(s.x * w, s.y * h, s.s, s.s);
      }
      ctx.globalAlpha = 1;
    }

    function animate(time) {
      drawScene(time || 0);
      requestAnimationFrame(animate);
    }

    // Interaction: drag + wheel to move/zoom
    let dragging = false;
    let lastX = 0, lastY = 0;
    canvas.addEventListener("mousedown", (e) => {
      dragging = true;
      lastX = e.clientX; lastY = e.clientY;
    });
    addEventListener("mouseup", () => dragging = false);
    addEventListener("mousemove", (e) => {
      if (!dragging) return;
      offsetX += e.clientX - lastX;
      offsetY += e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
    });
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.92 : 1.08;
      zoom = Math.min(2.4, Math.max(0.4, zoom * delta));
    }, { passive: false });

    prepareScene();
    createFloaters();
    animate(0);
  </script>
</body>
</html>
