<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>体素雪人 - Happy Snowman</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(180deg, #1a2a4a 0%, #2d4a7c 40%, #4a7ab0 70%, #8ab4d8 100%);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        .title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 2rem;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
            letter-spacing: 5px;
            z-index: 100;
            pointer-events: none;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
        }

        .controls button {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            border-radius: 25px;
            transition: all 0.3s;
        }

        .controls button:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        .stats {
            position: fixed;
            top: 70px;
            left: 20px;
            color: rgba(255,255,255,0.8);
            font-size: 12px;
            z-index: 100;
            background: rgba(0,0,0,0.3);
            padding: 10px 15px;
            border-radius: 10px;
        }

        .snowflake {
            position: fixed;
            color: white;
            font-size: 20px;
            pointer-events: none;
            z-index: 50;
            animation: fall linear infinite;
            opacity: 0.8;
        }

        @keyframes fall {
            0% {
                transform: translateY(-10vh) rotate(0deg);
            }
            100% {
                transform: translateY(110vh) rotate(360deg);
            }
        }
    </style>
</head>
<body>
    <h1 class="title">❄️ Happy Snowman ❄️</h1>
    <div id="canvas-container"></div>
    <div class="controls">
        <button id="toggleRotation">暂停/继续旋转</button>
        <button id="toggleSnow">开/关雪花</button>
    </div>
    <div class="stats" id="stats">加载中...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== 配置 ====================
        const VOXEL_SIZE = 1;
        let isAutoRotating = true;
        let snowEnabled = true;

        // ==================== Three.js 初始化 ====================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();

        // 相机
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 45);
        camera.lookAt(0, 10, 0);

        // 渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // ==================== 材质定义 ====================
        const materials = {
            snow: new THREE.MeshLambertMaterial({ color: 0xffffff }),
            coal: new THREE.MeshLambertMaterial({ color: 0x1a1a1a }),
            carrot: new THREE.MeshLambertMaterial({ color: 0xff6600 }),
            hat: new THREE.MeshLambertMaterial({ color: 0x1a1a1a }),
            hatBand: new THREE.MeshLambertMaterial({ color: 0xcc0000 }),
            scarf: new THREE.MeshLambertMaterial({ color: 0xcc0000 }),
            scarfStripe: new THREE.MeshLambertMaterial({ color: 0x0066cc }),
            arm: new THREE.MeshLambertMaterial({ color: 0x4a3728 }),
            ground: new THREE.MeshLambertMaterial({ color: 0xe8e8f0 }),
            smile: new THREE.MeshLambertMaterial({ color: 0x1a1a1a })
        };

        // ==================== 体素数据收集 ====================
        const voxelData = {};

        function addVoxel(x, y, z, materialKey) {
            if (!voxelData[materialKey]) {
                voxelData[materialKey] = [];
            }
            voxelData[materialKey].push({ x, y, z });
        }

        // 添加球体体素
        function addSphere(centerX, centerY, centerZ, radius, materialKey) {
            const r2 = radius * radius;
            for (let x = -radius; x <= radius; x++) {
                for (let y = -radius; y <= radius; y++) {
                    for (let z = -radius; z <= radius; z++) {
                        // 球体方程: x² + y² + z² ≤ r²
                        if (x * x + y * y + z * z <= r2) {
                            addVoxel(centerX + x, centerY + y, centerZ + z, materialKey);
                        }
                    }
                }
            }
        }

        // 添加椭球体（雪球形状）
        function addEllipsoid(centerX, centerY, centerZ, rx, ry, rz, materialKey) {
            for (let x = -rx; x <= rx; x++) {
                for (let y = -ry; y <= ry; y++) {
                    for (let z = -rz; z <= rz; z++) {
                        // 椭球方程: (x/a)² + (y/b)² + (z/c)² ≤ 1
                        if ((x * x) / (rx * rx) + (y * y) / (ry * ry) + (z * z) / (rz * rz) <= 1) {
                            addVoxel(centerX + x, centerY + y, centerZ + z, materialKey);
                        }
                    }
                }
            }
        }

        // ==================== 构建雪人 ====================
        function buildSnowman() {
            // === 身体（下球）- 半径7的椭球 ===
            addEllipsoid(0, 7, 0, 7, 6, 7, 'snow');

            // === 身体（中球）- 半径5.5的椭球 ===
            addEllipsoid(0, 17, 0, 5.5, 5, 5.5, 'snow');

            // === 头部 - 半径4.5的球 ===
            addSphere(0, 27, 0, 4.5, 'snow');

            // === 眼睛 ===
            // 左眼
            addVoxel(-2, 29, 4, 'coal');
            addVoxel(-2, 28, 4, 'coal');
            addVoxel(-1, 29, 4, 'coal');
            addVoxel(-1, 28, 4, 'coal');

            // 右眼
            addVoxel(2, 29, 4, 'coal');
            addVoxel(2, 28, 4, 'coal');
            addVoxel(1, 29, 4, 'coal');
            addVoxel(1, 28, 4, 'coal');

            // === 鼻子（胡萝卜）===
            for (let z = 5; z <= 9; z++) {
                const width = z < 7 ? 1 : 0;
                for (let x = -width; x <= width; x++) {
                    addVoxel(x, 27, z, 'carrot');
                }
            }

            // === 微笑的嘴巴 ===
            // 微笑曲线
            const smilePoints = [
                [-3, 25, 4], [-2, 24, 4.5], [-1, 24, 4.5], [0, 24, 4.5],
                [1, 24, 4.5], [2, 24, 4.5], [3, 25, 4]
            ];
            smilePoints.forEach(([x, y, z]) => {
                addVoxel(x, y, z, 'smile');
                addVoxel(x, y, z - 0.5, 'smile');
            });

            // === 帽子 ===
            // 帽檐
            for (let x = -4; x <= 4; x++) {
                for (let z = -4; z <= 4; z++) {
                    if (x * x + z * z <= 20) {
                        addVoxel(x, 32, z, 'hat');
                    }
                }
            }

            // 帽身
            for (let y = 33; y <= 40; y++) {
                for (let x = -3; x <= 3; x++) {
                    for (let z = -3; z <= 3; z++) {
                        if (x * x + z * z <= 10) {
                            addVoxel(x, y, z, 'hat');
                        }
                    }
                }
            }

            // 帽子红带
            for (let x = -3; x <= 3; x++) {
                for (let z = -3; z <= 3; z++) {
                    if (x * x + z * z <= 10) {
                        addVoxel(x, 35, z, 'hatBand');
                        addVoxel(x, 34, z, 'hatBand');
                    }
                }
            }

            // === 围巾 ===
            // 围巾缠绕脖子
            for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
                const x = Math.round(Math.cos(angle) * 6);
                const z = Math.round(Math.sin(angle) * 6);
                addVoxel(x, 22, z, 'scarf');
                addVoxel(x, 21, z, 'scarf');

                // 条纹
                if (Math.floor(angle * 3) % 2 === 0) {
                    addVoxel(x, 22, z, 'scarfStripe');
                }
            }

            // 围巾垂下部分
            for (let y = 20; y >= 10; y--) {
                addVoxel(7, y, 0, 'scarf');
                addVoxel(8, y, 0, 'scarf');
                if (y % 3 === 0) {
                    addVoxel(7, y, 0, 'scarfStripe');
                    addVoxel(8, y, 0, 'scarfStripe');
                }
            }

            // 围巾末端
            for (let y = 9; y >= 7; y--) {
                addVoxel(7, y, 0, 'scarf');
                addVoxel(8, y, 0, 'scarf');
                addVoxel(9, y, 0, 'scarf');
            }

            // === 纽扣 ===
            addVoxel(0, 19, 5, 'coal');
            addVoxel(0, 17, 5.5, 'coal');
            addVoxel(0, 15, 6, 'coal');

            // 身体上的纽扣
            addVoxel(0, 11, 6.5, 'coal');
            addVoxel(0, 8, 7, 'coal');
            addVoxel(0, 5, 7, 'coal');

            // === 手臂（树枝）===
            // 左臂
            for (let x = -8; x >= -18; x--) {
                addVoxel(x, 18, 0, 'arm');
            }
            // 左手分支
            addVoxel(-14, 19, 0, 'arm');
            addVoxel(-15, 20, 0, 'arm');
            addVoxel(-14, 19, 1, 'arm');
            addVoxel(-14, 19, -1, 'arm');

            // 右臂
            for (let x = 8; x <= 18; x++) {
                addVoxel(x, 18, 0, 'arm');
            }
            // 右手分支
            addVoxel(14, 19, 0, 'arm');
            addVoxel(15, 20, 0, 'arm');
            addVoxel(14, 19, 1, 'arm');
            addVoxel(14, 19, -1, 'arm');

            // === 地面雪地 ===
            for (let x = -25; x <= 25; x++) {
                for (let z = -25; z <= 25; z++) {
                    // 添加一些起伏
                    const height = Math.sin(x * 0.3) * Math.cos(z * 0.3) * 0.5;
                    if (Math.random() > 0.3) {
                        addVoxel(x, Math.floor(height) - 1, z, 'ground');
                    }
                }
            }
        }

        // ==================== 创建 InstancedMesh ====================
        const geometry = new THREE.BoxGeometry(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE);

        function createInstancedMeshes() {
            let totalVoxels = 0;
            const meshGroup = new THREE.Group();

            for (const [materialKey, positions] of Object.entries(voxelData)) {
                const count = positions.length;
                totalVoxels += count;

                const material = materials[materialKey];
                const mesh = new THREE.InstancedMesh(geometry, material, count);

                const matrix = new THREE.Matrix4();
                positions.forEach((pos, index) => {
                    matrix.setPosition(pos.x * VOXEL_SIZE, pos.y * VOXEL_SIZE, pos.z * VOXEL_SIZE);
                    mesh.setMatrixAt(index, matrix);
                });

                mesh.instanceMatrix.needsUpdate = true;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                meshGroup.add(mesh);
            }

            scene.add(meshGroup);
            return totalVoxels;
        }

        // ==================== 光照 ====================
        const ambientLight = new THREE.AmbientLight(0x8888ff, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(30, 50, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        // 补光
        const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
        fillLight.position.set(-20, 20, -20);
        scene.add(fillLight);

        // ==================== 雪花效果 ====================
        const snowflakes = [];

        function createSnowflake() {
            if (!snowEnabled || snowflakes.length > 100) return;

            const snowflake = document.createElement('div');
            snowflake.className = 'snowflake';
            snowflake.innerHTML = '❄';
            snowflake.style.left = Math.random() * 100 + 'vw';
            snowflake.style.animationDuration = (5 + Math.random() * 5) + 's';
            snowflake.style.fontSize = (10 + Math.random() * 15) + 'px';
            snowflake.style.opacity = 0.5 + Math.random() * 0.5;

            document.body.appendChild(snowflake);
            snowflakes.push(snowflake);

            setTimeout(() => {
                snowflake.remove();
                const index = snowflakes.indexOf(snowflake);
                if (index > -1) snowflakes.splice(index, 1);
            }, 10000);
        }

        setInterval(createSnowflake, 200);

        // ==================== 相机控制 ====================
        let cameraAngle = 0;
        let cameraHeight = 20;
        let cameraDistance = 45;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function updateCamera() {
            if (isAutoRotating) {
                cameraAngle += 0.003;
            }
            camera.position.x = Math.sin(cameraAngle) * cameraDistance;
            camera.position.z = Math.cos(cameraAngle) * cameraDistance;
            camera.position.y = cameraHeight;
            camera.lookAt(0, 12, 0);
        }

        // 鼠标拖动
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            cameraAngle -= deltaX * 0.01;
            cameraHeight = Math.max(5, Math.min(50, cameraHeight - deltaY * 0.2));
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mouseup', () => isDragging = false);
        renderer.domElement.addEventListener('mouseleave', () => isDragging = false);

        // 滚轮缩放
        renderer.domElement.addEventListener('wheel', (e) => {
            cameraDistance = Math.max(20, Math.min(80, cameraDistance + e.deltaY * 0.05));
        });

        // 触摸支持
        renderer.domElement.addEventListener('touchstart', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        renderer.domElement.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const deltaX = e.touches[0].clientX - previousMousePosition.x;
            const deltaY = e.touches[0].clientY - previousMousePosition.y;
            cameraAngle -= deltaX * 0.01;
            cameraHeight = Math.max(5, Math.min(50, cameraHeight - deltaY * 0.2));
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        renderer.domElement.addEventListener('touchend', () => isDragging = false);

        // ==================== 动画循环 ====================
        let voxelCount = 0;
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;

        function animate() {
            requestAnimationFrame(animate);
            updateCamera();
            renderer.render(scene, camera);

            // FPS计算
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('stats').innerHTML =
                    `FPS: ${fps}<br>体素数量: ${voxelCount}<br>Draw Calls: ${renderer.info.render.calls}`;
            }
        }

        // ==================== 控制按钮 ====================
        document.getElementById('toggleRotation').addEventListener('click', () => {
            isAutoRotating = !isAutoRotating;
        });

        document.getElementById('toggleSnow').addEventListener('click', () => {
            snowEnabled = !snowEnabled;
            if (!snowEnabled) {
                snowflakes.forEach(s => s.remove());
                snowflakes.length = 0;
            }
        });

        // ==================== 窗口大小调整 ====================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==================== 初始化 ====================
        buildSnowman();
        voxelCount = createInstancedMeshes();
        animate();

        console.log(`⛄ 雪人加载完成！
- 体素数量: ${voxelCount}
- 使用 InstancedMesh 优化渲染
- WebGL GPU 加速
- 鼠标拖动旋转 / 滚轮缩放`);
    </script>
</body>
</html>
