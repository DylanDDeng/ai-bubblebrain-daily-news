<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 魔方</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            z-index: 100;
        }
        #controls button {
            margin: 5px;
            padding: 8px 12px;
            cursor: pointer;
            background: #4CAF50;
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 14px;
        }
        #controls button:hover {
            background: #45a049;
        }
        #controls h3 {
            margin: 0 0 10px 0;
        }
        .face-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        .face-controls button {
            flex: 1;
            min-width: 60px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>魔方控制</h3>
        <div>
            <button onclick="resetCube()">重置魔方</button>
            <button onclick="scrambleCube()">打乱魔方</button>
        </div>
        <div class="face-controls">
            <button onclick="rotateFace('U')">U (上)</button>
            <button onclick="rotateFace('D')">D (下)</button>
            <button onclick="rotateFace('F')">F (前)</button>
            <button onclick="rotateFace('B')">B (后)</button>
            <button onclick="rotateFace('L')">L (左)</button>
            <button onclick="rotateFace('R')">R (右)</button>
        </div>
        <p style="font-size: 12px; margin-top: 10px;">使用鼠标拖动旋转视角</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, cubes = [];
        let isAnimating = false;
        const cubeSize = 1;
        const gap = 0.05;
        const colors = {
            right: 0xff0000,   // 红色
            left: 0xffa500,    // 橙色
            top: 0xffffff,     // 白色
            bottom: 0xffff00,  // 黄色
            front: 0x00ff00,   // 绿色
            back: 0x0000ff     // 蓝色
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(4, 4, 4);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            createCube();
            setupMouseControls();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createCube() {
            cubes = [];
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const materials = [
                            new THREE.MeshPhongMaterial({ color: x === 1 ? colors.right : 0x111111 }),  // 右
                            new THREE.MeshPhongMaterial({ color: x === -1 ? colors.left : 0x111111 }), // 左
                            new THREE.MeshPhongMaterial({ color: y === 1 ? colors.top : 0x111111 }),   // 上
                            new THREE.MeshPhongMaterial({ color: y === -1 ? colors.bottom : 0x111111 }), // 下
                            new THREE.MeshPhongMaterial({ color: z === 1 ? colors.front : 0x111111 }), // 前
                            new THREE.MeshPhongMaterial({ color: z === -1 ? colors.back : 0x111111 })  // 后
                        ];

                        const geometry = new THREE.BoxGeometry(cubeSize - gap, cubeSize - gap, cubeSize - gap);
                        const cube = new THREE.Mesh(geometry, materials);
                        cube.position.set(
                            x * (cubeSize + gap),
                            y * (cubeSize + gap),
                            z * (cubeSize + gap)
                        );
                        cube.castShadow = true;
                        cube.receiveShadow = true;
                        cube.userData = { x, y, z };
                        scene.add(cube);
                        cubes.push(cube);
                    }
                }
            }
        }

        function resetCube() {
            if (isAnimating) return;
            cubes.forEach(cube => scene.remove(cube));
            createCube();
        }

        function scrambleCube() {
            if (isAnimating) return;
            const moves = ['U', 'D', 'F', 'B', 'L', 'R'];
            const count = 20;
            let moveIndex = 0;

            function makeNextMove() {
                if (moveIndex >= count) {
                    return;
                }
                const randomMove = moves[Math.floor(Math.random() * moves.length)];
                rotateFace(randomMove, true).then(() => {
                    moveIndex++;
                    setTimeout(makeNextMove, 100);
                });
            }

            makeNextMove();
        }

        function rotateFace(face, isScramble = false) {
            if (isAnimating) return Promise.resolve();
            isAnimating = true;

            const faceCubes = getCubesOnFace(face);
            const axis = getAxis(face);
            const direction = getDirection(face);
            const rotationAngle = Math.PI / 2 * direction;

            const pivot = new THREE.Object3D();
            pivot.rotation.set(0, 0, 0);
            scene.add(pivot);

            faceCubes.forEach(cube => {
                pivot.attach(cube);
            });

            return new Promise(resolve => {
                const duration = 300;
                const startRotation = pivot.rotation[axis];
                const startTime = Date.now();

                function animateRotation() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easedProgress = 1 - Math.pow(1 - progress, 3);
                    pivot.rotation[axis] = startRotation + rotationAngle * easedProgress;

                    if (progress < 1) {
                        requestAnimationFrame(animateRotation);
                    } else {
                        pivot.rotation[axis] = startRotation + rotationAngle;
                        pivot.updateMatrixWorld();

                        faceCubes.forEach(cube => {
                            scene.attach(cube);
                            cube.position.x = Math.round(cube.position.x / (cubeSize + gap)) * (cubeSize + gap);
                            cube.position.y = Math.round(cube.position.y / (cubeSize + gap)) * (cubeSize + gap);
                            cube.position.z = Math.round(cube.position.z / (cubeSize + gap)) * (cubeSize + gap);
                            cube.rotation.x = Math.round(cube.rotation.x / (Math.PI / 2)) * (Math.PI / 2);
                            cube.rotation.y = Math.round(cube.rotation.y / (Math.PI / 2)) * (Math.PI / 2);
                            cube.rotation.z = Math.round(cube.rotation.z / (Math.PI / 2)) * (Math.PI / 2);
                        });

                        scene.remove(pivot);
                        isAnimating = false;
                        resolve();
                    }
                }

                animateRotation();
            });
        }

        function getCubesOnFace(face) {
            return cubes.filter(cube => {
                const pos = cube.position;
                const threshold = (cubeSize + gap) / 2;
                switch (face) {
                    case 'U': return Math.abs(pos.y - (cubeSize + gap)) < threshold;
                    case 'D': return Math.abs(pos.y + (cubeSize + gap)) < threshold;
                    case 'F': return Math.abs(pos.z - (cubeSize + gap)) < threshold;
                    case 'B': return Math.abs(pos.z + (cubeSize + gap)) < threshold;
                    case 'L': return Math.abs(pos.x + (cubeSize + gap)) < threshold;
                    case 'R': return Math.abs(pos.x - (cubeSize + gap)) < threshold;
                    default: return false;
                }
            });
        }

        function getAxis(face) {
            switch (face) {
                case 'U':
                case 'D': return 'y';
                case 'F':
                case 'B': return 'z';
                case 'L':
                case 'R': return 'x';
                default: return 'y';
            }
        }

        function getDirection(face) {
            switch (face) {
                case 'U':
                case 'F':
                case 'R': return -1;
                case 'D':
                case 'B':
                case 'L': return 1;
                default: return -1;
            }
        }

        function setupMouseControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let theta = Math.PI / 4;
            let phi = Math.PI / 4;
            const radius = 6;

            const canvas = renderer.domElement;

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                theta -= deltaX * 0.01;
                phi -= deltaY * 0.01;

                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

                camera.position.x = radius * Math.sin(phi) * Math.cos(theta);
                camera.position.y = radius * Math.cos(phi);
                camera.position.z = radius * Math.sin(phi) * Math.sin(theta);
                camera.lookAt(0, 0, 0);

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>