<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Dragon</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: linear-gradient(to bottom, #1a1a2e, #16213e, #0f3460); font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #info { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); color: #fff; font-size: 18px; text-shadow: 0 0 10px rgba(255, 100, 50, 0.8); z-index: 100; pointer-events: none; }
        #controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; z-index: 100; }
        .btn { padding: 12px 25px; font-size: 16px; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; font-weight: bold; }
        .btn-fly { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; }
        .btn-fly:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(231, 76, 60, 0.6); }
        .btn-fire { background: linear-gradient(135deg, #f39c12, #e67e22); color: white; }
        .btn-fire:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(243, 156, 18, 0.6); }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="info">Voxel Dragon</div>
    <div id="controls">
        <button class="btn btn-fly" onclick="toggleFlight()">Toggle Flight</button>
        <button class="btn btn-fire" onclick="toggleFire()">Toggle Fire Breath</button>
    </div>

    <script type="importmap">
        {"imports": {"three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"}}
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let dragon, leftWing, rightWing, tail;
        let isFlying = false, isFiring = false;
        let fireParticles = [];
        let clock = new THREE.Clock();
        let time = 0;

        const voxelSize = 1;
        const dragonColors = {
            body: 0x2d5a27, belly: 0x8fbc8f, wing: 0x8b0000, wingMembrane: 0xcd5c5c,
            eye: 0xffff00, horn: 0x4a4a4a, spike: 0x1a1a1a, fire: 0xff4500
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 15, 25);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 15;
            controls.maxDistance = 50;

            addLights();
            createDragon();
            createStars();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function addLights() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const moonLight = new THREE.DirectionalLight(0x8888ff, 0.8);
            moonLight.position.set(20, 30, 10);
            moonLight.castShadow = true;
            scene.add(moonLight);

            const fillLight = new THREE.PointLight(0xff6600, 0.5, 50);
            fillLight.position.set(-10, 10, 5);
            scene.add(fillLight);
        }

        function createVoxel(x, y, z, color, size = voxelSize) {
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshPhongMaterial({ color, flatShading: true });
            const voxel = new THREE.Mesh(geometry, material);
            voxel.position.set(x, y, z);
            voxel.castShadow = true;
            voxel.receiveShadow = true;
            return voxel;
        }

        function createDragon() {
            dragon = new THREE.Group();
            createBody();
            createHead();
            createWings();
            createTail();
            createLegs();
            createSpikes();
            dragon.position.set(0, 5, 0);
            dragon.rotation.y = Math.PI;
            scene.add(dragon);
        }

        function createBody() {
            const body = new THREE.Group();
            for (let y = -3; y <= 2; y++) {
                for (let x = -2; x <= 2; x++) {
                    for (let z = -4; z <= 2; z++) {
                        const dist = Math.sqrt(x*x + z*z);
                        if (dist <= 2.5) {
                            let voxelColor = dragonColors.body;
                            if (y < -1 && Math.abs(x) <= 1) voxelColor = dragonColors.belly;
                            if (y === 2 && (x === -2 || x === 2)) voxelColor = dragonColors.wing;
                            body.add(createVoxel(x, y, z, voxelColor));
                        }
                    }
                }
            }
            dragon.add(body);
        }

        function createHead() {
            const head = new THREE.Group();
            for (let y = -1; y <= 2; y++) {
                for (let x = -2; x <= 2; x++) {
                    for (let z = 3; z <= 6; z++) {
                        const inHead = z >= 3 && z <= 6 && !(z >= 5 && x === 0 && y <= 1);
                        if (inHead) {
                            let color = dragonColors.body;
                            if (y === 2) color = dragonColors.horn;
                            head.add(createVoxel(x, y, z, color));
                        }
                    }
                }
            }
            head.add(createVoxel(1, 1, 6, dragonColors.eye));
            head.add(createVoxel(-1, 1, 6, dragonColors.eye));
            for (let i = 0; i < 3; i++) {
                for (let side of [-1, 1]) {
                    head.add(createVoxel(side * 2, 3 - i, 3, dragonColors.horn));
                }
            }
            head.position.set(0, 1, 0);
            dragon.add(head);
        }

        function createWings() {
            leftWing = new THREE.Group();
            rightWing = new THREE.Group();
            const wingShape = [[0,0,0],[1,0,0],[2,0,0],[3,0,0],[4,0,0],[1,0,-1],[2,0,-1],[3,0,-1],[4,0,-1],[2,0,-2],[3,0,-2],[4,0,-2],[3,0,-3],[4,0,-3],[4,0,-4]];
            for (let pos of wingShape) {
                let [x, y, z] = pos;
                let color = z < -1 ? dragonColors.wingMembrane : dragonColors.wing;
                let size = z < -1 ? 0.8 : 1;
                leftWing.add(createVoxel(x, y, z, color, size));
                rightWing.add(createVoxel(x, y, z, color, size));
            }
            leftWing.position.set(-3, 2, 0);
            rightWing.position.set(3, 2, 0);
            dragon.add(leftWing);
            dragon.add(rightWing);
        }

        function createTail() {
            tail = new THREE.Group();
            const tailSegments = [{pos:[0,-1,-5],s:2},{pos:[0,-1,-7],s:2},{pos:[0,0,-9],s:1.5},{pos:[0,0,-11],s:1.5},{pos:[0,0,-13],s:1},{pos:[0,0,-15],s:0.8}];
            for (let i = 0; i < tailSegments.length; i++) {
                let color = i < 2 ? dragonColors.body : (i < 4 ? dragonColors.spike : dragonColors.wing);
                tail.add(createVoxel(tailSegments[i].pos[0], tailSegments[i].pos[1], tailSegments[i].pos[2], color, tailSegments[i].s));
            }
            dragon.add(tail);
        }

        function createLegs() {
            const legPositions = [{x:-2,z:-2},{x:2,z:-2},{x:-2,z:1},{x:2,z:1}];
            for (let legPos of legPositions) {
                const leg = new THREE.Group();
                for (let y = 0; y > -4; y--) leg.add(createVoxel(0, y, 0, dragonColors.body));
                leg.add(createVoxel(-1, -3, 0, dragonColors.body));
                leg.add(createVoxel(1, -3, 0, dragonColors.body));
                leg.position.set(legPos.x, -2, legPos.z);
                dragon.add(leg);
            }
        }

        function createSpikes() {
            for (let i = 0; i < 8; i++) {
                const spike = new THREE.Group();
                for (let j = 0; j < 3 - Math.floor(i/3); j++) spike.add(createVoxel(0, j, 0, dragonColors.spike, 0.6));
                spike.position.set(0, 3, -3 + i);
                dragon.add(spike);
            }
        }

        function createFireParticle() {
            const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const material = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(0.05 + Math.random() * 0.1, 1, 0.5 + Math.random() * 0.5),
                transparent: true, opacity: 1
            });
            const particle = new THREE.Mesh(geometry, material);
            particle.position.set(1, 8, 7);
            particle.userData = {
                velocity: new THREE.Vector3((Math.random() - 0.3) * 0.5, (Math.random() - 0.5) * 0.3, Math.random() * 0.8 + 0.5),
                life: 1, decay: 0.02 + Math.random() * 0.02
            };
            scene.add(particle);
            fireParticles.push(particle);
        }

        function updateFireParticles() {
            for (let i = fireParticles.length - 1; i >= 0; i--) {
                const p = fireParticles[i];
                p.userData.velocity.y -= 0.01;
                p.position.add(p.userData.velocity);
                p.userData.life -= p.userData.decay;
                p.material.opacity = p.userData.life;
                p.scale.setScalar(p.userData.life);
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    fireParticles.splice(i, 1);
                }
            }
        }

        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(1500);
            for (let i = 0; i < 1500; i += 3) {
                positions[i] = (Math.random() - 0.5) * 200;
                positions[i + 1] = Math.random() * 100 + 20;
                positions[i + 2] = (Math.random() - 0.5) * 200;
            }
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8 });
            scene.add(new THREE.Points(starGeometry, starMaterial));
        }

        window.toggleFlight = () => isFlying = !isFlying;
        window.toggleFire = () => isFiring = !isFiring;

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += clock.getDelta();

            if (isFlying) {
                dragon.position.y = 5 + Math.sin(time * 2) * 0.3;
                dragon.rotation.z = Math.sin(time * 1.5) * 0.1;
                dragon.position.x += Math.sin(time * 0.5) * 0.02;
                dragon.position.z += Math.cos(time * 0.3) * 0.02;
            }

            if (leftWing && rightWing) {
                const wingAngle = Math.sin(time * 8) * 0.8 + 0.2;
                leftWing.rotation.z = -wingAngle;
                rightWing.rotation.z = wingAngle;
            }

            if (tail) tail.rotation.x = Math.sin(time * 3) * 0.1;

            if (isFiring) for (let i = 0; i < 3; i++) createFireParticle();
            updateFireParticles();

            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
