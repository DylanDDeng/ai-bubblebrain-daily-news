<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>p5.js 旋转六边形弹球</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
        }
        #canvas-container {
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <script>
        let balls = [];
        const numBalls = 10;
        const hexRadius = 250;
        let hexRotation = 0;
        const gravity = 0.3;
        const elasticity = 0.85;
        const friction = 0.99;
        const ballRadius = 20;

        function setup() {
            let canvas = createCanvas(800, 800);
            canvas.parent('canvas-container');
            
            for (let i = 0; i < numBalls; i++) {
                balls.push(new Ball(
                    random(-100, 100),
                    random(-100, 100),
                    ballRadius,
                    color(random(100, 255), random(100, 255), random(100, 255))
                ));
            }
        }

        function draw() {
            background(26, 26, 46);
            translate(width / 2, height / 2);

            hexRotation += 0.01;

            drawHexagon();
            handleCollisions();

            for (let ball of balls) {
                ball.update();
                ball.display();
            }
        }

        function drawHexagon() {
            push();
            rotate(hexRotation);
            
            noFill();
            stroke(100, 200, 255);
            strokeWeight(4);
            beginShape();
            for (let i = 0; i < 6; i++) {
                let angle = TWO_PI / 6 * i;
                let x = hexRadius * cos(angle);
                let y = hexRadius * sin(angle);
                vertex(x, y);
            }
            endShape(CLOSE);
            
            stroke(100, 200, 255, 50);
            strokeWeight(2);
            beginShape();
            for (let i = 0; i < 6; i++) {
                let angle = TWO_PI / 6 * i;
                let x = (hexRadius + 20) * cos(angle);
                let y = (hexRadius + 20) * sin(angle);
                vertex(x, y);
            }
            endShape(CLOSE);
            
            pop();
        }

        function handleCollisions() {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    checkBallCollision(balls[i], balls[j]);
                }
            }
        }

        function checkBallCollision(ball1, ball2) {
            let dx = ball2.pos.x - ball1.pos.x;
            let dy = ball2.pos.y - ball1.pos.y;
            let distance = sqrt(dx * dx + dy * dy);
            let minDist = ball1.r + ball2.r;

            if (distance < minDist) {
                let angle = atan2(dy, dx);
                let overlap = minDist - distance;

                ball1.pos.x -= overlap / 2 * cos(angle);
                ball1.pos.y -= overlap / 2 * sin(angle);
                ball2.pos.x += overlap / 2 * cos(angle);
                ball2.pos.y += overlap / 2 * sin(angle);

                let v1x = ball1.vel.x;
                let v1y = ball1.vel.y;
                let v2x = ball2.vel.x;
                let v2y = ball2.vel.y;

                let newV1x = v2x;
                let newV1y = v2y;
                let newV2x = v1x;
                let newV2y = v1y;

                ball1.vel.x = newV1x * elasticity;
                ball1.vel.y = newV1y * elasticity;
                ball2.vel.x = newV2x * elasticity;
                ball2.vel.y = newV2y * elasticity;
            }
        }

        function getHexagonVertices() {
            let vertices = [];
            for (let i = 0; i < 6; i++) {
                let angle = TWO_PI / 6 * i + hexRotation;
                vertices.push(createVector(
                    hexRadius * cos(angle),
                    hexRadius * sin(angle)
                ));
            }
            return vertices;
        }

        function getClosestPointOnSegment(p, a, b) {
            let ab = p5.Vector.sub(b, a);
            let ap = p5.Vector.sub(p, a);
            let t = constrain(ap.dot(ab) / ab.dot(ab), 0, 1);
            return p5.Vector.add(a, p5.Vector.mult(ab, t));
        }

        class Ball {
            constructor(x, y, r, col) {
                this.pos = createVector(x, y);
                this.vel = createVector(random(-5, 5), random(-5, 5));
                this.r = r;
                this.col = col;
                this.mass = r * r;
            }

            update() {
                this.vel.y += gravity;
                this.vel.mult(friction);

                this.pos.add(this.vel);

                this.checkHexagonCollision();
            }

            checkHexagonCollision() {
                let vertices = getHexagonVertices();

                for (let i = 0; i < vertices.length; i++) {
                    let a = vertices[i];
                    let b = vertices[(i + 1) % vertices.length];
                    
                    let closest = getClosestPointOnSegment(this.pos, a, b);
                    let distance = p5.Vector.dist(this.pos, closest);

                    if (distance < this.r) {
                        let normal = p5.Vector.sub(this.pos, closest).normalize();
                        
                        this.pos = p5.Vector.add(closest, p5.Vector.mult(normal, this.r));
                        
                        let dot = this.vel.dot(normal);
                        this.vel.sub(p5.Vector.mult(normal, 2 * dot));
                        this.vel.mult(elasticity);
                        
                        let edge = p5.Vector.sub(b, a);
                        let angularVelocity = hexRotation * hexRadius;
                        let tangent = edge.copy().normalize().rotate(HALF_PI);
                        let wallVel = p5.Vector.mult(tangent, angularVelocity * 0.5);
                        this.vel.add(p5.Vector.mult(wallVel, 0.1));
                    }
                }
            }

            display() {
                push();
                
                let brightCol = lerpColor(this.col, color(255), 0.3);
                let darkCol = lerpColor(this.col, color(0), 0.2);
                
                let gradient = drawingContext.createRadialGradient(
                    this.pos.x - this.r * 0.3, 
                    this.pos.y - this.r * 0.3, 
                    0,
                    this.pos.x, 
                    this.pos.y, 
                    this.r
                );
                gradient.addColorStop(0, brightCol.toString());
                gradient.addColorStop(1, darkCol.toString());
                
                drawingContext.fillStyle = gradient;
                noStroke();
                ellipse(this.pos.x, this.pos.y, this.r * 2);
                
                noFill();
                stroke(255, 255, 255, 150);
                strokeWeight(1);
                ellipse(this.pos.x - this.r * 0.2, this.pos.y - this.r * 0.2, this.r * 0.5);
                pop();
            }
        }
    </script>
</body>
</html>