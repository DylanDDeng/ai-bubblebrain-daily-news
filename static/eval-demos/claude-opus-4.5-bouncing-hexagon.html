<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—‹è½¬å…­è¾¹å½¢å†…çš„å¼¹è·³çƒ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgba(255,255,255,0.8);
            font-size: 14px;
            z-index: 100;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            font-weight: 500;
        }
        .btn-reset { background: linear-gradient(135deg, #e57373, #ef5350); }
        .btn-gravity { background: linear-gradient(135deg, #64b5f6, #42a5f5); }
        .btn-speed { background: linear-gradient(135deg, #81c784, #66bb6a); }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(0,0,0,0.3); }
    </style>
</head>
<body>
    <div id="info">
        <div>â¬†ï¸â¬‡ï¸ è°ƒæ•´é‡åŠ› | â¬…ï¸â¡ï¸ è°ƒæ•´æ—‹è½¬é€Ÿåº¦</div>
        <div>ç‚¹å‡»æ·»åŠ æ–°çƒ | ç©ºæ ¼é”®é‡ç½®</div>
    </div>
    <div id="controls">
        <button class="btn btn-reset" onclick="resetBalls()">ğŸ”„ é‡ç½®</button>
        <button class="btn btn-gravity" onclick="toggleGravity()">ğŸŒ é‡åŠ›å¼€å…³</button>
        <button class="btn btn-speed" onclick="reverseRotation()">â†©ï¸ åè½¬æ—‹è½¬</button>
    </div>

    <script>
        // ç‰©ç†å‚æ•°
        let gravity = 0.5;
        let gravityEnabled = true;
        let restitution = 0.85;  // å¼¹æ€§ç³»æ•°
        let friction = 0.99;     // æ‘©æ“¦ç³»æ•°
        let rotationSpeed = 0.01;

        // å…­è¾¹å½¢å‚æ•°
        let hexRadius = 280;
        let hexAngle = 0;
        let hexCenter;

        // çƒæ•°ç»„
        let balls = [];
        const NUM_BALLS = 10;

        // é¢œè‰²æ•°ç»„
        const COLORS = [
            [255, 107, 107],  // çº¢
            [78, 205, 196],   // é’
            [255, 230, 109],  // é»„
            [170, 111, 255],  // ç´«
            [255, 171, 76],   // æ©™
            [46, 213, 115],   // ç»¿
            [255, 121, 198],  // ç²‰
            [116, 185, 255],  // è“
            [253, 203, 110],  // é‡‘
            [0, 210, 211],    // é’ç»¿
        ];

        class Ball {
            constructor(x, y, r, color) {
                this.pos = createVector(x, y);
                this.vel = createVector(random(-5, 5), random(-5, 5));
                this.acc = createVector(0, 0);
                this.r = r;
                this.mass = r * r;
                this.color = color;
                this.trail = [];
                this.maxTrail = 15;
            }

            applyForce(force) {
                let f = p5.Vector.div(force, this.mass);
                this.acc.add(f);
            }

            update() {
                // åº”ç”¨é‡åŠ›
                if (gravityEnabled) {
                    this.applyForce(createVector(0, gravity * this.mass));
                }

                // æ›´æ–°é€Ÿåº¦å’Œä½ç½®
                this.vel.add(this.acc);
                this.vel.mult(friction);
                this.pos.add(this.vel);
                this.acc.mult(0);

                // æ›´æ–°è½¨è¿¹
                this.trail.push(this.pos.copy());
                if (this.trail.length > this.maxTrail) {
                    this.trail.shift();
                }
            }

            draw() {
                // ç»˜åˆ¶è½¨è¿¹
                noFill();
                beginShape();
                for (let i = 0; i < this.trail.length; i++) {
                    let alpha = map(i, 0, this.trail.length, 0, 150);
                    stroke(this.color[0], this.color[1], this.color[2], alpha);
                    strokeWeight(map(i, 0, this.trail.length, 1, this.r * 0.8));
                    vertex(this.trail[i].x, this.trail[i].y);
                }
                endShape();

                // ç»˜åˆ¶çƒä½“ï¼ˆå¸¦æ¸å˜æ•ˆæœï¼‰
                noStroke();

                // å¤–å‘å…‰
                for (let i = 5; i > 0; i--) {
                    fill(this.color[0], this.color[1], this.color[2], 20);
                    ellipse(this.pos.x, this.pos.y, this.r * 2 + i * 8);
                }

                // ä¸»ä½“
                fill(this.color[0], this.color[1], this.color[2]);
                ellipse(this.pos.x, this.pos.y, this.r * 2);

                // é«˜å…‰
                fill(255, 255, 255, 180);
                ellipse(this.pos.x - this.r * 0.3, this.pos.y - this.r * 0.3, this.r * 0.6);
            }
        }

        function setup() {
            let canvas = createCanvas(windowWidth, windowHeight);
            hexCenter = createVector(width / 2, height / 2);
            hexRadius = min(width, height) * 0.38;
            resetBalls();
        }

        function resetBalls() {
            balls = [];
            for (let i = 0; i < NUM_BALLS; i++) {
                let angle = random(TWO_PI);
                let dist = random(50, hexRadius * 0.5);
                let x = hexCenter.x + cos(angle) * dist;
                let y = hexCenter.y + sin(angle) * dist;
                let r = random(15, 30);
                balls.push(new Ball(x, y, r, COLORS[i % COLORS.length]));
            }
        }

        function draw() {
            background(26, 26, 46);

            // æ›´æ–°å…­è¾¹å½¢è§’åº¦
            hexAngle += rotationSpeed;

            // ç»˜åˆ¶èƒŒæ™¯è£…é¥°
            drawBackground();

            // ç»˜åˆ¶å…­è¾¹å½¢
            drawHexagon();

            // æ›´æ–°å’Œç»˜åˆ¶çƒ
            for (let ball of balls) {
                ball.update();
                checkHexagonCollision(ball);
            }

            // çƒä¹‹é—´çš„ç¢°æ’
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    checkBallCollision(balls[i], balls[j]);
                }
            }

            // ç»˜åˆ¶çƒ
            for (let ball of balls) {
                ball.draw();
            }

            // ç»˜åˆ¶ä¿¡æ¯
            drawInfo();
        }

        function drawBackground() {
            // ç»˜åˆ¶æ—‹è½¬çš„èƒŒæ™¯çº¿æ¡
            push();
            translate(hexCenter.x, hexCenter.y);
            stroke(255, 255, 255, 10);
            strokeWeight(1);
            for (let i = 0; i < 12; i++) {
                let angle = i * PI / 6 + hexAngle * 0.5;
                line(0, 0, cos(angle) * max(width, height), sin(angle) * max(width, height));
            }
            pop();
        }

        function drawHexagon() {
            push();
            translate(hexCenter.x, hexCenter.y);
            rotate(hexAngle);

            // ç»˜åˆ¶å¤–å‘å…‰
            noFill();
            for (let i = 5; i > 0; i--) {
                stroke(100, 200, 255, 30 - i * 5);
                strokeWeight(i * 3);
                beginShape();
                for (let j = 0; j < 6; j++) {
                    let angle = j * PI / 3 - PI / 6;
                    vertex(cos(angle) * hexRadius, sin(angle) * hexRadius);
                }
                endShape(CLOSE);
            }

            // ä¸»å…­è¾¹å½¢
            stroke(100, 200, 255);
            strokeWeight(4);
            beginShape();
            for (let i = 0; i < 6; i++) {
                let angle = i * PI / 3 - PI / 6;
                vertex(cos(angle) * hexRadius, sin(angle) * hexRadius);
            }
            endShape(CLOSE);

            // é¡¶ç‚¹è£…é¥°
            fill(100, 200, 255);
            noStroke();
            for (let i = 0; i < 6; i++) {
                let angle = i * PI / 3 - PI / 6;
                ellipse(cos(angle) * hexRadius, sin(angle) * hexRadius, 12);
            }

            pop();
        }

        function getHexagonVertices() {
            let vertices = [];
            for (let i = 0; i < 6; i++) {
                let angle = i * PI / 3 - PI / 6 + hexAngle;
                vertices.push(createVector(
                    hexCenter.x + cos(angle) * hexRadius,
                    hexCenter.y + sin(angle) * hexRadius
                ));
            }
            return vertices;
        }

        function checkHexagonCollision(ball) {
            let vertices = getHexagonVertices();

            for (let i = 0; i < 6; i++) {
                let v1 = vertices[i];
                let v2 = vertices[(i + 1) % 6];

                // è®¡ç®—å¢™å£æ³•å‘é‡ï¼ˆæŒ‡å‘å†…éƒ¨ï¼‰
                let edge = p5.Vector.sub(v2, v1);
                let normal = createVector(-edge.y, edge.x);
                normal.normalize();

                // æ£€æŸ¥æ³•å‘é‡æ˜¯å¦æŒ‡å‘ä¸­å¿ƒ
                let toCenter = p5.Vector.sub(hexCenter, v1);
                if (normal.dot(toCenter) < 0) {
                    normal.mult(-1);
                }

                // è®¡ç®—çƒåˆ°å¢™å£çš„è·ç¦»
                let ballToV1 = p5.Vector.sub(ball.pos, v1);
                let distance = ballToV1.dot(normal);

                // è®¡ç®—çƒåœ¨è¾¹ä¸Šçš„æŠ•å½±ç‚¹
                let edgeLength = edge.mag();
                let projection = ballToV1.dot(edge) / edgeLength;

                // æ£€æŸ¥æ˜¯å¦åœ¨è¾¹çš„èŒƒå›´å†…
                if (projection >= 0 && projection <= edgeLength) {
                    if (distance < ball.r) {
                        // è®¡ç®—å¢™å£åœ¨ç¢°æ’ç‚¹çš„é€Ÿåº¦ï¼ˆç”±äºæ—‹è½¬ï¼‰
                        let collisionPoint = p5.Vector.add(v1, p5.Vector.mult(edge, projection / edgeLength));
                        let radiusVec = p5.Vector.sub(collisionPoint, hexCenter);

                        // å¢™å£é€Ÿåº¦ = Ï‰ Ã— rï¼ˆå‚ç›´äºåŠå¾„å‘é‡ï¼‰
                        let wallVel = createVector(-radiusVec.y, radiusVec.x);
                        wallVel.mult(rotationSpeed);

                        // ç›¸å¯¹é€Ÿåº¦
                        let relVel = p5.Vector.sub(ball.vel, wallVel);
                        let velNormal = relVel.dot(normal);

                        // åªåœ¨çƒå‘å¢™å£ç§»åŠ¨æ—¶å¤„ç†ç¢°æ’
                        if (velNormal < 0) {
                            // åå°„é€Ÿåº¦
                            let impulse = p5.Vector.mult(normal, -velNormal * (1 + restitution));
                            ball.vel.add(impulse);

                            // æ·»åŠ å¢™å£é€Ÿåº¦çš„å½±å“
                            ball.vel.add(p5.Vector.mult(wallVel, 0.5));

                            // åº”ç”¨åˆ‡å‘æ‘©æ“¦
                            let tangent = createVector(-normal.y, normal.x);
                            let velTangent = relVel.dot(tangent);
                            ball.vel.sub(p5.Vector.mult(tangent, velTangent * (1 - friction)));
                        }

                        // å°†çƒæ¨å‡ºå¢™å£
                        let overlap = ball.r - distance;
                        ball.pos.add(p5.Vector.mult(normal, overlap + 1));
                    }
                }
            }

            // æ£€æŸ¥ä¸é¡¶ç‚¹çš„ç¢°æ’
            for (let v of vertices) {
                let dist = p5.Vector.dist(ball.pos, v);
                if (dist < ball.r) {
                    let normal = p5.Vector.sub(ball.pos, v);
                    normal.normalize();

                    let velNormal = ball.vel.dot(normal);
                    if (velNormal < 0) {
                        let impulse = p5.Vector.mult(normal, -velNormal * (1 + restitution));
                        ball.vel.add(impulse);
                    }

                    let overlap = ball.r - dist;
                    ball.pos.add(p5.Vector.mult(normal, overlap + 1));
                }
            }
        }

        function checkBallCollision(ball1, ball2) {
            let dist = p5.Vector.dist(ball1.pos, ball2.pos);
            let minDist = ball1.r + ball2.r;

            if (dist < minDist && dist > 0) {
                // ç¢°æ’æ³•å‘é‡
                let normal = p5.Vector.sub(ball2.pos, ball1.pos);
                normal.normalize();

                // ç›¸å¯¹é€Ÿåº¦
                let relVel = p5.Vector.sub(ball1.vel, ball2.vel);
                let velNormal = relVel.dot(normal);

                // åªåœ¨çƒé è¿‘æ—¶å¤„ç†
                if (velNormal > 0) {
                    // è®¡ç®—å†²é‡ï¼ˆè€ƒè™‘è´¨é‡ï¼‰
                    let totalMass = ball1.mass + ball2.mass;
                    let impulse = (2 * velNormal * restitution) / totalMass;

                    ball1.vel.sub(p5.Vector.mult(normal, impulse * ball2.mass));
                    ball2.vel.add(p5.Vector.mult(normal, impulse * ball1.mass));
                }

                // åˆ†ç¦»é‡å çš„çƒ
                let overlap = minDist - dist;
                let separation = p5.Vector.mult(normal, overlap / 2 + 1);
                ball1.pos.sub(separation);
                ball2.pos.add(separation);
            }
        }

        function drawInfo() {
            fill(255, 255, 255, 200);
            noStroke();
            textSize(14);
            textAlign(RIGHT, TOP);
            text(`çƒæ•°: ${balls.length}`, width - 20, 20);
            text(`é‡åŠ›: ${gravityEnabled ? gravity.toFixed(2) : 'å…³é—­'}`, width - 20, 40);
            text(`æ—‹è½¬é€Ÿåº¦: ${(rotationSpeed * 100).toFixed(1)}`, width - 20, 60);
            text(`å¼¹æ€§: ${(restitution * 100).toFixed(0)}%`, width - 20, 80);
        }

        function keyPressed() {
            if (keyCode === UP_ARROW) {
                gravity = min(gravity + 0.1, 2);
            } else if (keyCode === DOWN_ARROW) {
                gravity = max(gravity - 0.1, 0);
            } else if (keyCode === LEFT_ARROW) {
                rotationSpeed = max(rotationSpeed - 0.005, -0.05);
            } else if (keyCode === RIGHT_ARROW) {
                rotationSpeed = min(rotationSpeed + 0.005, 0.05);
            } else if (key === ' ') {
                resetBalls();
            }
        }

        function mousePressed() {
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨å…­è¾¹å½¢å†…
            let vertices = getHexagonVertices();
            if (isInsideHexagon(mouseX, mouseY, vertices)) {
                let r = random(15, 30);
                let color = COLORS[balls.length % COLORS.length];
                balls.push(new Ball(mouseX, mouseY, r, color));
            }
        }

        function isInsideHexagon(x, y, vertices) {
            let inside = true;
            for (let i = 0; i < 6; i++) {
                let v1 = vertices[i];
                let v2 = vertices[(i + 1) % 6];
                let edge = p5.Vector.sub(v2, v1);
                let toPoint = createVector(x - v1.x, y - v1.y);
                let cross = edge.x * toPoint.y - edge.y * toPoint.x;
                if (cross > 0) {
                    inside = false;
                    break;
                }
            }
            return inside;
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            hexCenter = createVector(width / 2, height / 2);
            hexRadius = min(width, height) * 0.38;
        }

        function toggleGravity() {
            gravityEnabled = !gravityEnabled;
        }

        function reverseRotation() {
            rotationSpeed *= -1;
        }
    </script>
</body>
</html>
