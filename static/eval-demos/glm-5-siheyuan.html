<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>传统中国四合院 - 体素艺术 (WebGL优化版)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            overflow: hidden;
            font-family: 'STKaiti', 'KaiTi', serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        .title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #d4af37;
            font-size: 2.5rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
            letter-spacing: 10px;
            z-index: 100;
            pointer-events: none;
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #888;
            font-size: 14px;
            z-index: 100;
        }

        .controls {
            position: fixed;
            top: 80px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }

        .controls button {
            padding: 10px 20px;
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid #d4af37;
            color: #d4af37;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.3s;
        }

        .controls button:hover {
            background: rgba(212, 175, 55, 0.4);
        }

        .stats {
            position: fixed;
            top: 80px;
            left: 20px;
            color: #d4af37;
            font-size: 12px;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1 class="title">四 合 院</h1>
    <div id="canvas-container"></div>
    <div class="info">中国传统民居 · 体素艺术 (WebGL优化版)</div>
    <div class="controls">
        <button id="toggleRotation">暂停/继续旋转</button>
        <button id="changeTime">切换昼夜</button>
        <button id="resetCamera">重置视角</button>
    </div>
    <div class="stats" id="stats"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== 配置 ====================
        const VOXEL_SIZE = 1;
        let isNight = true;
        let isAutoRotating = true;

        // ==================== Three.js 初始化 ====================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();

        // 相机设置
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 35, 50);
        camera.lookAt(0, 5, 0);

        // 渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // ==================== 颜色材质定义 ====================
        const colors = {
            wallRed: { main: 0x8b0000, dark: 0x6b0000, light: 0xab2020 },
            wallGray: { main: 0x8b8b8b, dark: 0x6b6b6b, light: 0xababab },
            roofTile: { main: 0x2d2d2d, dark: 0x1d1d1d, light: 0x3d3d3d },
            roofEdge: { main: 0x8b4513, dark: 0x6b3510, light: 0xa05520 },
            ground: { main: 0x4a3c2c, dark: 0x3a2c1c, light: 0x5a4c3c },
            courtyard: { main: 0xc9b896, dark: 0xa99876, light: 0xd9c8a6 },
            door: { main: 0x8b0000, dark: 0x5a0000, light: 0xab2020 },
            doorGold: { main: 0xd4af37, dark: 0x947f17, light: 0xe4bf47 },
            window: { main: 0x1a1a1a, dark: 0x0a0a0a, light: 0x2a2a2a },
            pillar: { main: 0x8b0000, dark: 0x6b0000, light: 0xab2020 },
            step: { main: 0x9b9b9b, dark: 0x7b7b7b, light: 0xbbbbbb },
            treeTrunk: { main: 0x5c4033, dark: 0x3c2013, light: 0x6c5043 },
            treeLeaves: { main: 0x228b22, dark: 0x1a6b1a, light: 0x32ab32 },
            lantern: { main: 0xff4444, dark: 0xcc2222, light: 0xff6666 }
        };

        // 材质缓存 - 使用简单材质提高性能
        const materialCache = {};

        function getMaterial(colorKey, emissive = false) {
            const cacheKey = `${colorKey}_${emissive}`;
            if (materialCache[cacheKey]) return materialCache[cacheKey];

            const color = colors[colorKey];
            const material = new THREE.MeshLambertMaterial({
                color: color.main,
                emissive: emissive ? color.main : 0x000000,
                emissiveIntensity: emissive ? 0.5 : 0
            });
            materialCache[cacheKey] = material;
            return material;
        }

        // ==================== 体素数据收集 ====================
        // 不直接创建mesh，而是收集体素位置，最后批量创建
        const voxelData = {};

        function addVoxel(x, y, z, colorKey) {
            if (!voxelData[colorKey]) {
                voxelData[colorKey] = [];
            }
            voxelData[colorKey].push({ x, y, z });
        }

        function addBlock(startX, startY, startZ, width, height, depth, colorKey) {
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    for (let z = 0; z < depth; z++) {
                        addVoxel(startX + x, startY + y, startZ + z, colorKey);
                    }
                }
            }
        }

        // ==================== 建筑构建函数 ====================

        // 创建屋顶（坡形）
        function createRoof(startX, startY, startZ, width, depth, isMainBuilding = false) {
            const roofHeight = isMainBuilding ? 4 : 3;
            const overhang = 2;

            for (let layer = 0; layer < roofHeight; layer++) {
                const currentWidth = width + overhang * 2 - layer * 2;
                const currentDepth = depth + overhang * 2 - layer * 2;
                const xOffset = layer - overhang;
                const zOffset = layer - overhang;

                for (let x = 0; x < currentWidth; x++) {
                    for (let z = 0; z < currentDepth; z++) {
                        addVoxel(
                            startX + xOffset + x,
                            startY + layer,
                            startZ + zOffset + z,
                            'roofTile'
                        );
                    }
                }

                // 屋檐边缘
                if (layer === 0) {
                    for (let x = 0; x < currentWidth; x++) {
                        addVoxel(startX + xOffset + x, startY, startZ + zOffset, 'roofEdge');
                        addVoxel(startX + xOffset + x, startY, startZ + zOffset + currentDepth - 1, 'roofEdge');
                    }
                }
            }
        }

        // 创建门
        function createDoor(startX, startY, startZ) {
            addBlock(startX, startY, startZ, 1, 6, 1, 'doorGold');
            addBlock(startX + 5, startY, startZ, 1, 6, 1, 'doorGold');
            addBlock(startX, startY + 6, startZ, 6, 1, 1, 'doorGold');

            addBlock(startX + 1, startY, startZ, 2, 6, 1, 'door');
            addBlock(startX + 3, startY, startZ, 2, 6, 1, 'door');

            addVoxel(startX + 1, startY + 3, startZ - 1, 'doorGold');
            addVoxel(startX + 4, startY + 3, startZ - 1, 'doorGold');

            addBlock(startX - 1, startY - 1, startZ - 1, 7, 1, 2, 'step');
            addBlock(startX, startY - 2, startZ - 2, 5, 1, 1, 'step');
        }

        // 创建窗户
        function createWindow(startX, startY, startZ, width, height) {
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    addVoxel(startX + x, startY + y, startZ, 'window');
                }
            }
        }

        // 创建柱子
        function createPillar(startX, startY, startZ, height) {
            addBlock(startX, startY, startZ, 1, height, 1, 'pillar');
        }

        // 创建树
        function createTree(startX, startY, startZ) {
            addBlock(startX, startY, startZ, 2, 4, 2, 'treeTrunk');

            for (let y = 4; y < 8; y++) {
                const size = y < 6 ? 4 : 3;
                const offset = Math.floor((4 - size) / 2);
                addBlock(startX - 1 + offset, startY + y, startZ - 1 + offset, size, 1, size, 'treeLeaves');
            }
        }

        // 灯笼数组（用于动画）
        const lanternMeshes = [];

        // 创建灯笼
        function createLantern(startX, startY, startZ) {
            addVoxel(startX, startY, startZ, 'lantern');
            addVoxel(startX, startY + 1, startZ, 'lantern');
            addVoxel(startX, startY - 1, startZ, 'doorGold');
        }

        // 创建正房（北房）
        function createMainBuilding() {
            const baseX = -12;
            const baseZ = -18;

            addBlock(baseX, 0, baseZ, 24, 1, 10, 'ground');

            addBlock(baseX, 1, baseZ, 24, 7, 1, 'wallGray');
            addBlock(baseX, 1, baseZ + 9, 24, 7, 1, 'wallGray');

            for (let z = 1; z < 9; z++) {
                addBlock(baseX, 1, baseZ + z, 1, 7, 1, 'wallGray');
                addBlock(baseX + 23, 1, baseZ + z, 1, 7, 1, 'wallGray');
            }

            createWindow(baseX + 3, 3, baseZ, 4, 3);
            createWindow(baseX + 10, 3, baseZ, 4, 3);
            createWindow(baseX + 17, 3, baseZ, 4, 3);

            createWindow(baseX + 3, 3, baseZ + 9, 4, 3);
            createWindow(baseX + 17, 3, baseZ + 9, 4, 3);

            addBlock(baseX + 9, 1, baseZ + 9, 6, 2, 1, 'doorGold');
            createWindow(baseX + 10, 4, baseZ + 9, 4, 3);

            createPillar(baseX + 2, 1, baseZ + 9, 7);
            createPillar(baseX + 21, 1, baseZ + 9, 7);
            createPillar(baseX + 2, 1, baseZ, 7);
            createPillar(baseX + 21, 1, baseZ, 7);

            createRoof(baseX, 8, baseZ - 1, 24, 11, true);

            createLantern(baseX + 3, 7, baseZ + 10);
            createLantern(baseX + 20, 7, baseZ + 10);
        }

        // 创建东西厢房
        function createSideBuilding(baseX, baseZ, isEast) {
            addBlock(baseX, 0, baseZ, 8, 1, 18, 'ground');

            addBlock(baseX, 1, baseZ, 8, 5, 1, 'wallGray');
            addBlock(baseX, 1, baseZ + 17, 8, 5, 1, 'wallGray');

            if (isEast) {
                addBlock(baseX, 1, baseZ, 1, 5, 18, 'wallGray');
            } else {
                addBlock(baseX + 7, 1, baseZ, 1, 5, 18, 'wallGray');
            }

            createWindow(baseX + 1, 2, baseZ + 3, 6, 3);
            createWindow(baseX + 1, 2, baseZ + 10, 6, 3);

            createPillar(baseX, 1, baseZ + 2, 5);
            createPillar(baseX, 1, baseZ + 15, 5);

            createRoof(baseX - 1, 6, baseZ - 1, 10, 20, false);
        }

        // 创建倒座房（南房）
        function createSouthBuilding() {
            const baseX = -12;
            const baseZ = 12;

            addBlock(baseX, 0, baseZ, 24, 1, 8, 'ground');

            addBlock(baseX, 1, baseZ, 24, 5, 1, 'wallGray');
            addBlock(baseX, 1, baseZ + 7, 24, 5, 1, 'wallGray');

            addBlock(baseX, 1, baseZ, 1, 5, 8, 'wallGray');
            addBlock(baseX + 23, 1, baseZ, 1, 5, 8, 'wallGray');

            createDoor(baseX + 9, 1, baseZ);

            createWindow(baseX + 2, 2, baseZ + 7, 5, 3);
            createWindow(baseX + 17, 2, baseZ + 7, 5, 3);

            createPillar(baseX + 1, 1, baseZ + 7, 5);
            createPillar(baseX + 22, 1, baseZ + 7, 5);

            createRoof(baseX, 6, baseZ - 1, 24, 10, false);
        }

        // 创建院落
        function createCourtyard() {
            for (let x = -11; x < 12; x++) {
                for (let z = -7; z < 12; z++) {
                    addVoxel(x, 0, z, 'courtyard');
                }
            }

            for (let z = -7; z < 12; z++) {
                addVoxel(0, 0, z, 'step');
                addVoxel(-1, 0, z, 'step');
                addVoxel(1, 0, z, 'step');
            }

            createTree(-8, 0, 2);
            createTree(7, 0, -3);

            addBlock(-5, 0, 5, 2, 1, 2, 'step');
            addBlock(4, 0, 5, 2, 1, 2, 'step');
        }

        // 创建影壁
        function createScreenWall() {
            const baseX = -4;
            const baseZ = 10;

            addBlock(baseX, 0, baseZ, 8, 1, 1, 'step');
            addBlock(baseX, 1, baseZ, 8, 5, 1, 'wallGray');
            addBlock(baseX, 6, baseZ, 8, 1, 1, 'doorGold');
            addBlock(baseX - 1, 1, baseZ, 1, 5, 1, 'doorGold');
            addBlock(baseX + 8, 1, baseZ, 1, 5, 1, 'doorGold');
            addBlock(baseX - 1, 7, baseZ, 10, 1, 2, 'roofTile');
        }

        // ==================== 场景构建 ====================

        function buildScene() {
            // 收集地面体素
            for (let x = -15; x < 15; x++) {
                for (let z = -22; z < 22; z++) {
                    addVoxel(x, -1, z, 'ground');
                }
            }

            createMainBuilding();
            createSideBuilding(-15, -12, false);
            createSideBuilding(8, -12, true);
            createSouthBuilding();
            createCourtyard();
            createScreenWall();
        }

        // ==================== 使用 InstancedMesh 批量渲染 ====================

        const geometry = new THREE.BoxGeometry(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE);

        function createInstancedMeshes() {
            let totalVoxels = 0;

            for (const [colorKey, positions] of Object.entries(voxelData)) {
                const count = positions.length;
                totalVoxels += count;

                const isLantern = colorKey === 'lantern';
                const material = getMaterial(colorKey, isLantern);
                const mesh = new THREE.InstancedMesh(geometry, material, count);

                const matrix = new THREE.Matrix4();
                positions.forEach((pos, index) => {
                    matrix.setPosition(pos.x * VOXEL_SIZE, pos.y * VOXEL_SIZE, pos.z * VOXEL_SIZE);
                    mesh.setMatrixAt(index, matrix);

                    // 记录灯笼mesh索引用于动画
                    if (isLantern) {
                        lanternMeshes.push({ mesh, index, baseY: pos.y * VOXEL_SIZE });
                    }
                });

                mesh.instanceMatrix.needsUpdate = true;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
            }

            return totalVoxels;
        }

        // ==================== 光照设置 ====================

        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 80, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 200;
        directionalLight.shadow.camera.left = -60;
        directionalLight.shadow.camera.right = 60;
        directionalLight.shadow.camera.top = 60;
        directionalLight.shadow.camera.bottom = -60;
        scene.add(directionalLight);

        // 灯笼点光源
        const pointLights = [];

        function createPointLights() {
            const lanternPositions = voxelData['lantern'] || [];
            // 只为部分灯笼创建点光源（性能优化）
            const samplePositions = lanternPositions.filter((_, i) => i % 2 === 0).slice(0, 6);

            samplePositions.forEach(pos => {
                const light = new THREE.PointLight(0xff4444, 0.5, 15);
                light.position.set(pos.x * VOXEL_SIZE, pos.y * VOXEL_SIZE, pos.z * VOXEL_SIZE);
                scene.add(light);
                pointLights.push(light);
            });
        }

        // ==================== 天空背景 ====================

        function setNightSky() {
            scene.background = new THREE.Color(0x1a1a2e);
            ambientLight.intensity = 0.3;
            directionalLight.intensity = 0.3;
            directionalLight.color.setHex(0x8888ff);
            pointLights.forEach(light => light.intensity = 1);
        }

        function setDaySky() {
            scene.background = new THREE.Color(0x87CEEB);
            ambientLight.intensity = 0.6;
            directionalLight.intensity = 1;
            directionalLight.color.setHex(0xffffff);
            pointLights.forEach(light => light.intensity = 0.3);
        }

        // ==================== 相机控制 ====================

        let cameraAngle = 0;
        let cameraHeight = 35;
        let cameraDistance = 70;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function updateCamera() {
            if (isAutoRotating) {
                cameraAngle += 0.002;
            }
            camera.position.x = Math.cos(cameraAngle) * cameraDistance;
            camera.position.z = Math.sin(cameraAngle) * cameraDistance;
            camera.position.y = cameraHeight;
            camera.lookAt(0, 5, 0);
        }

        // 鼠标控制
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            cameraAngle -= deltaX * 0.01;
            cameraHeight = Math.max(10, Math.min(80, cameraHeight - deltaY * 0.3));

            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mouseup', () => isDragging = false);
        renderer.domElement.addEventListener('mouseleave', () => isDragging = false);

        // 滚轮缩放
        renderer.domElement.addEventListener('wheel', (e) => {
            cameraDistance = Math.max(30, Math.min(150, cameraDistance + e.deltaY * 0.1));
        });

        // ==================== 动画循环 ====================

        let time = 0;
        let voxelCount = 0;

        function animate() {
            requestAnimationFrame(animate);

            time += 0.05;

            // 灯笼发光动画
            if (isNight) {
                const glowIntensity = 0.3 + Math.sin(time) * 0.2;
                const lanternMaterial = materialCache['lantern_true'];
                if (lanternMaterial) {
                    lanternMaterial.emissiveIntensity = glowIntensity;
                }
            }

            // 点光源闪烁
            pointLights.forEach((light, i) => {
                light.intensity = isNight ? (0.8 + Math.sin(time + i) * 0.3) : 0.2;
            });

            updateCamera();
            renderer.render(scene, camera);

            // 更新FPS显示
            updateStats();
        }

        // ==================== 性能统计 ====================

        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;

        function updateStats() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('stats').innerHTML =
                    `FPS: ${fps}<br>体素数量: ${voxelCount}<br>Draw Calls: ${renderer.info.render.calls}`;
            }
        }

        // ==================== 控制按钮 ====================

        document.getElementById('toggleRotation').addEventListener('click', () => {
            isAutoRotating = !isAutoRotating;
        });

        document.getElementById('changeTime').addEventListener('click', () => {
            isNight = !isNight;
            if (isNight) {
                setNightSky();
            } else {
                setDaySky();
            }
        });

        document.getElementById('resetCamera').addEventListener('click', () => {
            cameraAngle = 0;
            cameraHeight = 35;
            cameraDistance = 70;
        });

        // ==================== 窗口大小调整 ====================

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==================== 初始化 ====================

        buildScene();
        voxelCount = createInstancedMeshes();
        createPointLights();
        setNightSky();
        animate();

        console.log(`四合院体素艺术加载完成！
- 体素数量: ${voxelCount}
- 使用 InstancedMesh 批量渲染
- WebGL GPU 加速
- 鼠标拖动旋转视角
- 滚轮缩放`);
    </script>
</body>
</html>
