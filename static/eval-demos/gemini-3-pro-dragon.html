<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Dragon</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
        }

        canvas {
            display: block;
        }

        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>

<body>
    <div id="instructions">
        <h2>Voxel Dragon</h2>
        <p>Drag to rotate</p>
        <p>Scroll to zoom</p>
    </div>
    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Setup Scene ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x202025); // Dark background for contrast
        scene.fog = new THREE.Fog(0x202025, 20, 100);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 20, -30);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 5, 0);

        // --- Lights ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffaa00, 1.5); // Warm sun light
        dirLight.position.set(-10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 50;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        scene.add(dirLight);

        // --- Voxel Engine ---
        const voxelGeo = new THREE.BoxGeometry(1, 1, 1);

        // Cache materials to improve performance
        const materials = {};
        function getMaterial(color) {
            if (!materials[color]) {
                materials[color] = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.8,
                    metalness: 0.1
                });
            }
            return materials[color];
        }

        // Helper to add a voxel
        function addVoxel(parent, x, y, z, colorHex) {
            const mesh = new THREE.Mesh(voxelGeo, getMaterial(colorHex));
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            parent.add(mesh);
        }

        // --- Dragon Construction ---
        const dragonGroup = new THREE.Group();
        scene.add(dragonGroup);

        const COLOR_SCALES = 0x4ade80; // Green scales
        const COLOR_BELLY = 0xfef08a;  // Yellow belly
        const COLOR_HORN = 0xfdad58;   // Orange horns/spikes
        const COLOR_EYE_WHITE = 0xffffff;
        const COLOR_EYE_PUPIL = 0x000000;
        const COLOR_WING_MEMBRANE = 0xff8c00; // Dark Orange wings

        // 1. Body
        const bodyGroup = new THREE.Group();
        dragonGroup.add(bodyGroup);

        // Main torso block
        for (let x = -2; x <= 2; x++) {
            for (let y = 0; y < 3; y++) {
                for (let z = -3; z <= 3; z++) {
                    // Belly check
                    let color = (y === 0 && Math.abs(x) < 2) ? COLOR_BELLY : COLOR_SCALES;
                    // Tapering
                    if (Math.abs(x) === 2 && (y === 2 || z === -3 || z === 3)) continue;
                    addVoxel(bodyGroup, x, y, z, color);
                }
            }
        }
        // Spikes on back
        for (let z = -2; z <= 2; z += 2) {
            addVoxel(bodyGroup, 0, 3, z, COLOR_HORN);
        }

        // 2. Head (Attached to a neck group for movement if needed, but simplistic here)
        const headGroup = new THREE.Group();
        headGroup.position.set(0, 3, 4); // Position head at front of body
        dragonGroup.add(headGroup);

        // Neck
        for (let y = 0; y < 3; y++) addVoxel(headGroup, 0, y, 0, COLOR_SCALES);

        // Skull
        const headBaseY = 3;
        for (let x = -1; x <= 1; x++) {
            for (let y = 0; y < 2; y++) {
                for (let z = 0; z <= 3; z++) {
                    addVoxel(headGroup, x, headBaseY + y, z, COLOR_SCALES);
                }
            }
        }
        // Snout
        addVoxel(headGroup, 0, headBaseY, 3, COLOR_BELLY);

        // Eyes
        addVoxel(headGroup, 1, headBaseY + 1, 1, COLOR_EYE_WHITE);
        addVoxel(headGroup, 1.1, headBaseY + 1, 1, COLOR_EYE_PUPIL); // Pupil pops out slightly
        addVoxel(headGroup, -1, headBaseY + 1, 1, COLOR_EYE_WHITE);
        addVoxel(headGroup, -1.1, headBaseY + 1, 1, COLOR_EYE_PUPIL);

        // Horns
        addVoxel(headGroup, 1, headBaseY + 2, -1, COLOR_HORN);
        addVoxel(headGroup, -1, headBaseY + 2, -1, COLOR_HORN);

        // 3. Tail
        const tailGroup = new THREE.Group();
        tailGroup.position.set(0, 1, -3); // Start at back of body
        dragonGroup.add(tailGroup);

        // Build tail segments
        for (let i = 0; i < 6; i++) {
            // Tapering tail
            addVoxel(tailGroup, 0, 0, -i - 1, COLOR_SCALES);
            if (i % 2 === 0) addVoxel(tailGroup, 0, 1, -i - 1, COLOR_HORN); // Spikes
        }

        // 4. Wings
        const wingPivotLeft = new THREE.Group();
        wingPivotLeft.position.set(2, 2, 0); // Shoulder position
        dragonGroup.add(wingPivotLeft);

        const wingPivotRight = new THREE.Group();
        wingPivotRight.position.set(-2, 2, 0);
        dragonGroup.add(wingPivotRight);

        // Helper to build wing
        function buildWing(parent, isLeft) {
            const dir = isLeft ? 1 : -1;
            // Bone structure
            for (let i = 1; i <= 6; i++) {
                addVoxel(parent, i * dir, 0, 0, COLOR_SCALES);
                // Membrane hanging down/back
                for (let j = 1; j <= i && j < 5; j++) {
                    addVoxel(parent, i * dir, 0, j, COLOR_WING_MEMBRANE);
                }
            }
        }
        buildWing(wingPivotLeft, true);
        buildWing(wingPivotRight, false);

        // 5. Legs
        const legFL = new THREE.Group(); legFL.position.set(2, 0, 3);
        const legFR = new THREE.Group(); legFR.position.set(-2, 0, 3);
        const legBL = new THREE.Group(); legBL.position.set(2, 0, -3);
        const legBR = new THREE.Group(); legBR.position.set(-2, 0, -3);
        dragonGroup.add(legFL); dragonGroup.add(legFR); dragonGroup.add(legBL); dragonGroup.add(legBR);

        function buildLeg(parent) {
            addVoxel(parent, 0, -1, 0, COLOR_SCALES);
            addVoxel(parent, 0, -2, 0, COLOR_SCALES);
            addVoxel(parent, 0, -3, 1, COLOR_HORN); // Claw
        }
        buildLeg(legFL); buildLeg(legFR); buildLeg(legBL); buildLeg(legBR);


        // --- Fire Particle System ---
        const fireParticles = [];
        const fireParams = {
            count: 50,
            speed: 0.4,
            spread: 0.1
        };

        function spawnFire() {
            // Spawn at dragon mouth
            // Head relative pos: (0, 3, 4) -> Snout is roughly +3 z from there + world pos
            // We need world position of the mouth. 
            // Simplified: mouth is at roughly (0, 6, 7.5) relative to dragon center

            const mouthPos = new THREE.Vector3(0, 6.5, 7.5);
            mouthPos.applyMatrix4(dragonGroup.matrixWorld);

            const particle = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.5, 0.5),
                new THREE.MeshBasicMaterial({ color: 0xff4500, transparent: true, opacity: 1 })
            );

            // Random spread
            particle.position.copy(mouthPos);
            particle.position.x += (Math.random() - 0.5) * 0.5;
            particle.position.y += (Math.random() - 0.5) * 0.5;

            // Velocity Vector
            const velocity = new THREE.Vector3(0, -0.2, 1); // Down and forward
            velocity.x += (Math.random() - 0.5) * fireParams.spread;
            velocity.y += (Math.random() - 0.5) * fireParams.spread;
            velocity.normalize().multiplyScalar(fireParams.speed);

            scene.add(particle);
            fireParticles.push({ mesh: particle, velocity: velocity, life: 1.0 });
        }


        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            const delta = clock.getDelta();

            // Hovering
            dragonGroup.position.y = Math.sin(time * 2) * 0.5;

            // Wing Flapping
            // Rotate around Z axis at the pivot
            wingPivotLeft.rotation.z = Math.sin(time * 10) * 0.5 - 0.2;
            wingPivotRight.rotation.z = -Math.sin(time * 10) * 0.5 + 0.2;

            // Tail Swaying
            // Simple sway
            tailGroup.rotation.y = Math.sin(time * 5) * 0.3;

            // Head bobbing slightly
            headGroup.rotation.x = Math.sin(time * 3) * 0.1;

            // Leg dangling logic (simple counter sway)
            legFL.rotation.x = Math.sin(time * 3) * 0.2;
            legFR.rotation.x = Math.cos(time * 3) * 0.2;
            legBL.rotation.x = Math.cos(time * 3) * 0.2;
            legBR.rotation.x = Math.sin(time * 3) * 0.2;

            // Fire Effect logic (constant stream)
            // Spawn fire occasionally
            spawnFire();
            spawnFire();

            // Update particles
            for (let i = fireParticles.length - 1; i >= 0; i--) {
                const p = fireParticles[i];
                p.mesh.position.add(p.velocity);
                p.life -= 0.02; // Decay

                // Visual updates
                p.mesh.scale.setScalar(p.life * 2); // Start big, shrink? Or Start small grow? Let's shrink
                p.mesh.rotation.x += 0.1;
                p.mesh.rotation.y += 0.1;

                // Color shift: Orange -> Yellow -> Smoke
                if (p.life < 0.5) p.mesh.material.color.setHex(0xffff00);
                if (p.life < 0.2) {
                    p.mesh.material.color.setHex(0x555555);
                    p.mesh.material.opacity = p.life * 5;
                }

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    // Dispose geometry/material to prevent leak if real app (optional for small demo)
                    fireParticles.splice(i, 1);
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        animate();

    </script>
</body>

</html>