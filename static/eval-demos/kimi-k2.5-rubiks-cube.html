<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js é­”æ–¹</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a2e; }
        #canvas-container { width: 100vw; height: 100vh; }
        .control-btn {
            transition: all 0.2s;
        }
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .control-btn:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <!-- UI æ§åˆ¶é¢æ¿ -->
    <div class="absolute top-4 left-4 z-10 bg-black/60 backdrop-blur-md rounded-xl p-4 text-white">
        <h1 class="text-xl font-bold mb-3">ğŸ² 3D é­”æ–¹</h1>
        
        <div class="space-y-2">
            <p class="text-xs text-gray-400 mb-2">ç‚¹å‡»æŒ‰é’®æ—‹è½¬å¯¹åº”å±‚</p>
            
            <!-- Xè½´æ—‹è½¬ -->
            <div class="flex gap-2">
                <button onclick="rotateLayer('x', 0, 1)" class="control-btn bg-red-600 hover:bg-red-500 px-3 py-1 rounded text-sm">å·¦</button>
                <button onclick="rotateLayer('x', 1, 1)" class="control-btn bg-red-600 hover:bg-red-500 px-3 py-1 rounded text-sm">ä¸­X</button>
                <button onclick="rotateLayer('x', 2, 1)" class="control-btn bg-red-600 hover:bg-red-500 px-3 py-1 rounded text-sm">å³</button>
            </div>
            
            <!-- Yè½´æ—‹è½¬ -->
            <div class="flex gap-2">
                <button onclick="rotateLayer('y', 2, 1)" class="control-btn bg-blue-600 hover:bg-blue-500 px-3 py-1 rounded text-sm">ä¸Š</button>
                <button onclick="rotateLayer('y', 1, 1)" class="control-btn bg-blue-600 hover:bg-blue-500 px-3 py-1 rounded text-sm">ä¸­Y</button>
                <button onclick="rotateLayer('y', 0, 1)" class="control-btn bg-blue-600 hover:bg-blue-500 px-3 py-1 rounded text-sm">ä¸‹</button>
            </div>
            
            <!-- Zè½´æ—‹è½¬ -->
            <div class="flex gap-2">
                <button onclick="rotateLayer('z', 2, 1)" class="control-btn bg-green-600 hover:bg-green-500 px-3 py-1 rounded text-sm">å‰</button>
                <button onclick="rotateLayer('z', 1, 1)" class="control-btn bg-green-600 hover:bg-green-500 px-3 py-1 rounded text-sm">ä¸­Z</button>
                <button onclick="rotateLayer('z', 0, 1)" class="control-btn bg-green-600 hover:bg-green-500 px-3 py-1 rounded text-sm">å</button>
            </div>
        </div>
        
        <div class="mt-4 pt-4 border-t border-white/20">
            <button onclick="scrambleCube()" class="control-btn w-full bg-purple-600 hover:bg-purple-500 px-4 py-2 rounded font-semibold mb-2">
                ğŸ”€ æ‰“ä¹±
            </button>
            <button onclick="resetCube()" class="control-btn w-full bg-yellow-600 hover:bg-yellow-500 px-4 py-2 rounded font-semibold">
                ğŸ”„ è¿˜åŸ
            </button>
        </div>
        
        <div class="mt-3 text-xs text-gray-400">
            <p>ğŸ–±ï¸ å·¦é”®æ‹–åŠ¨æ—‹è½¬è§†è§’</p>
            <p>ğŸ–±ï¸ æ»šè½®ç¼©æ”¾</p>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // ==================== é…ç½® ====================
        const CUBE_SIZE = 1;
        const SPACING = 0.02;
        const TOTAL_SIZE = CUBE_SIZE + SPACING;
        
        // é­”æ–¹é¢œè‰² (æ ‡å‡†é…è‰²)
        const COLORS = {
            U: 0xFFFFFF, // ä¸Š - ç™½
            D: 0xFFD500, // ä¸‹ - é»„
            F: 0x009E60, // å‰ - ç»¿
            B: 0x0051BA, // å - è“
            L: 0xFF5800, // å·¦ - æ©™
            R: 0xC41E3A, // å³ - çº¢
            CORE: 0x111111
        };

        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer, controls;
        let rubiksGroup; // æ•´ä¸ªé­”æ–¹çš„ç»„
        let cubies = []; // æ‰€æœ‰å°æ–¹å—
        let isRotating = false;
        
        // ==================== åˆå§‹åŒ– ====================
        function init() {
            const container = document.getElementById('canvas-container');
            
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(8, 6, 10);
            camera.lookAt(0, 0, 0);
            
            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // ç¯å…‰
            setupLights();
            
            // åˆ›å»ºé­”æ–¹
            createRubiksCube();
            
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
            
            // åŠ¨ç”»å¾ªç¯
            animate();
        }
        
        function setupLights() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(10, 10, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);
            
            const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
            fillLight.position.set(-10, 0, -10);
            scene.add(fillLight);
        }
        
        // ==================== åˆ›å»ºé­”æ–¹ ====================
        function createRubiksCube() {
            if (rubiksGroup) {
                scene.remove(rubiksGroup);
            }
            
            rubiksGroup = new THREE.Group();
            cubies = [];
            
            // åˆ›å»º 3x3x3 çš„å°ç«‹æ–¹ä½“
            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        const cubie = createCubie(x, y, z);
                        cubies.push(cubie);
                        rubiksGroup.add(cubie);
                    }
                }
            }
            
            scene.add(rubiksGroup);
        }
        
        function createCubie(x, y, z) {
            const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
            
            // ç¡®å®šæ¯ä¸ªé¢çš„é¢œè‰²
            // æè´¨é¡ºåº: Right (x+), Left (x-), Top (y+), Bottom (y-), Front (z+), Back (z-)
            const materials = [
                x === 2 ? new THREE.MeshStandardMaterial({ color: COLORS.R, roughness: 0.2, metalness: 0.1 }) : new THREE.MeshStandardMaterial({ color: COLORS.CORE }),
                x === 0 ? new THREE.MeshStandardMaterial({ color: COLORS.L, roughness: 0.2, metalness: 0.1 }) : new THREE.MeshStandardMaterial({ color: COLORS.CORE }),
                y === 2 ? new THREE.MeshStandardMaterial({ color: COLORS.U, roughness: 0.2, metalness: 0.1 }) : new THREE.MeshStandardMaterial({ color: COLORS.CORE }),
                y === 0 ? new THREE.MeshStandardMaterial({ color: COLORS.D, roughness: 0.2, metalness: 0.1 }) : new THREE.MeshStandardMaterial({ color: COLORS.CORE }),
                z === 2 ? new THREE.MeshStandardMaterial({ color: COLORS.F, roughness: 0.2, metalness: 0.1 }) : new THREE.MeshStandardMaterial({ color: COLORS.CORE }),
                z === 0 ? new THREE.MeshStandardMaterial({ color: COLORS.B, roughness: 0.2, metalness: 0.1 }) : new THREE.MeshStandardMaterial({ color: COLORS.CORE })
            ];
            
            const mesh = new THREE.Mesh(geometry, materials);
            
            // è®¾ç½®ä½ç½® (å°†ç´¢å¼• 0,1,2 æ˜ å°„åˆ° -1,0,1)
            mesh.position.set(
                (x - 1) * TOTAL_SIZE,
                (y - 1) * TOTAL_SIZE,
                (z - 1) * TOTAL_SIZE
            );
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // å­˜å‚¨åˆå§‹ä½ç½®ä¿¡æ¯
            mesh.userData = { 
                gridX: x, gridY: y, gridZ: z,
                initialGrid: { x, y, z }
            };
            
            return mesh;
        }
        
        // ==================== å±‚æ—‹è½¬ ====================
        function rotateLayer(axis, layerIndex, direction) {
            if (isRotating) return;
            isRotating = true;
            
            // æ‰¾å‡ºè¯¥å±‚çš„æ‰€æœ‰æ–¹å—
            const layerCubies = cubies.filter(cubie => {
                const data = cubie.userData;
                if (axis === 'x') return data.gridX === layerIndex;
                if (axis === 'y') return data.gridY === layerIndex;
                if (axis === 'z') return data.gridZ === layerIndex;
            });
            
            // åˆ›å»ºä¸´æ—¶æ—‹è½¬ç»„
            const pivot = new THREE.Group();
            pivot.position.set(0, 0, 0);
            scene.add(pivot);
            
            // å°†æ–¹å—çš„å½“å‰ä¸–ç•Œä½ç½®ä¿å­˜
            const originalTransforms = layerCubies.map(cubie => ({
                cubie: cubie,
                parent: cubie.parent,
                position: cubie.position.clone(),
                rotation: cubie.rotation.clone(),
                quaternion: cubie.quaternion.clone()
            }));
            
            // å°†æ–¹å—æ·»åŠ åˆ°æ—‹è½¬ç»„
            originalTransforms.forEach(item => {
                rubiksGroup.remove(item.cubie);
                pivot.attach(item.cubie);
            });
            
            // åŠ¨ç”»å‚æ•°
            const duration = 400;
            const startTime = Date.now();
            const targetAngle = direction * Math.PI / 2;
            
            function animateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = easeOutCubic(progress);
                const currentAngle = targetAngle * eased;
                
                pivot.rotation.set(0, 0, 0);
                if (axis === 'x') pivot.rotation.x = currentAngle;
                if (axis === 'y') pivot.rotation.y = currentAngle;
                if (axis === 'z') pivot.rotation.z = currentAngle;
                
                if (progress < 1) {
                    requestAnimationFrame(animateRotation);
                } else {
                    // åŠ¨ç”»å®Œæˆ
                    finalizeRotation(pivot, originalTransforms, axis, direction);
                    scene.remove(pivot);
                    isRotating = false;
                }
            }
            
            animateRotation();
        }
        
        function finalizeRotation(pivot, originalTransforms, axis, direction) {
            // æ›´æ–°æ–¹å—çš„ç½‘æ ¼åæ ‡
            originalTransforms.forEach(item => {
                const cubie = item.cubie;
                const data = cubie.userData;
                
                // è·å–æ—‹è½¬åçš„ç½‘æ ¼åæ ‡
                let { gridX, gridY, gridZ } = data;
                
                // æ ¹æ®è½´å’Œæ–¹å‘æ›´æ–°åæ ‡
                if (axis === 'x') {
                    // ç»•Xè½´æ—‹è½¬: yå’Œzäº¤æ¢
                    if (direction > 0) {
                        [gridY, gridZ] = [gridZ, 2 - gridY];
                    } else {
                        [gridY, gridZ] = [2 - gridZ, gridY];
                    }
                } else if (axis === 'y') {
                    // ç»•Yè½´æ—‹è½¬: xå’Œzäº¤æ¢
                    if (direction > 0) {
                        [gridX, gridZ] = [2 - gridZ, gridX];
                    } else {
                        [gridX, gridZ] = [gridZ, 2 - gridX];
                    }
                } else if (axis === 'z') {
                    // ç»•Zè½´æ—‹è½¬: xå’Œyäº¤æ¢
                    if (direction > 0) {
                        [gridX, gridY] = [gridY, 2 - gridX];
                    } else {
                        [gridX, gridY] = [2 - gridY, gridX];
                    }
                }
                
                // æ›´æ–°å­˜å‚¨çš„åæ ‡
                data.gridX = gridX;
                data.gridY = gridY;
                data.gridZ = gridZ;
                
                // å°†æ–¹å—é‡æ–°æ·»åŠ åˆ°é­”æ–¹ç»„
                pivot.remove(cubie);
                rubiksGroup.add(cubie);
                
                // æ›´æ–°ä½ç½®åˆ°æ–°çš„ç½‘æ ¼ä½ç½®
                cubie.position.set(
                    (gridX - 1) * TOTAL_SIZE,
                    (gridY - 1) * TOTAL_SIZE,
                    (gridZ - 1) * TOTAL_SIZE
                );
                
                // ä¿æŒæ—‹è½¬çŠ¶æ€
                cubie.rotation.copy(item.rotation);
                if (axis === 'x') cubie.rotateX(direction * Math.PI / 2);
                if (axis === 'y') cubie.rotateY(direction * Math.PI / 2);
                if (axis === 'z') cubie.rotateZ(direction * Math.PI / 2);
                
                // å››èˆäº”å…¥æ—‹è½¬è§’åº¦åˆ°90åº¦çš„å€æ•°
                cubie.rotation.x = Math.round(cubie.rotation.x / (Math.PI / 2)) * (Math.PI / 2);
                cubie.rotation.y = Math.round(cubie.rotation.y / (Math.PI / 2)) * (Math.PI / 2);
                cubie.rotation.z = Math.round(cubie.rotation.z / (Math.PI / 2)) * (Math.PI / 2);
            });
        }
        
        function easeOutCubic(x) {
            return 1 - Math.pow(1 - x, 3);
        }
        
        // ==================== æ‰“ä¹±é­”æ–¹ ====================
        function scrambleCube() {
            if (isRotating) return;
            
            const axes = ['x', 'y', 'z'];
            const layers = [0, 1, 2];
            const directions = [1, -1];
            const moves = [];
            
            // ç”Ÿæˆ20æ­¥éšæœºç§»åŠ¨
            for (let i = 0; i < 20; i++) {
                const axis = axes[Math.floor(Math.random() * axes.length)];
                const layer = layers[Math.floor(Math.random() * layers.length)];
                const dir = directions[Math.floor(Math.random() * directions.length)];
                moves.push({ axis, layer, dir });
            }
            
            let moveIndex = 0;
            function doNextMove() {
                if (moveIndex >= moves.length) return;
                const move = moves[moveIndex];
                rotateLayer(move.axis, move.layer, move.dir);
                moveIndex++;
                
                // ç­‰å¾…å½“å‰æ—‹è½¬å®Œæˆ
                const checkInterval = setInterval(() => {
                    if (!isRotating) {
                        clearInterval(checkInterval);
                        doNextMove();
                    }
                }, 100);
            }
            
            doNextMove();
        }
        
        // ==================== è¿˜åŸé­”æ–¹ ====================
        function resetCube() {
            if (isRotating) return;
            
            // é‡æ–°åˆ›å»ºç«‹æ–¹ä½“
            createRubiksCube();
            
            // å…¥åœºåŠ¨ç”»
            cubies.forEach((cubie, index) => {
                const data = cubie.userData;
                const delay = (data.gridX + data.gridY + data.gridZ) * 50;
                
                cubie.scale.set(0, 0, 0);
                setTimeout(() => {
                    let s = 0;
                    function grow() {
                        s += 0.15;
                        cubie.scale.set(s, s, s);
                        if (s < 1) requestAnimationFrame(grow);
                    }
                    grow();
                }, delay);
            });
        }
        
        // ==================== çª—å£è°ƒæ•´ ====================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // ==================== å¯åŠ¨ ====================
        init();
    </script>
</body>
</html>
