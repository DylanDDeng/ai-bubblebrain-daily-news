<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Chinatown Paifang</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0d0d26;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Courier New', monospace;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
    </style>
    <!-- Import map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="info">Voxel Chinatown Paifang</div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- PALETTE ---
        const COLORS = {
            RED: 0xC41E3A,       // Chinese Red
            GOLD: 0xFFD700,      // Roof Gold
            WHITE: 0xEEEEEE,     // Decorative White
            STONE: 0x808080,     // Base Stone
            PAVEMENT: 0x444444,  // Dark Grey Pavement
            WOOD_DARK: 0x3E2723, // Signboard background
            DARK_BLUE: 0x0F1035, // Night Sky
            GREEN: 0x2E8B57,     // Decorative Green
            GLOW_RED: 0xFF4500,  // Lantern Glow
            GLOW_YELLOW: 0xFFFFE0 // Lantern Light
        };

        // --- VOXEL BUILDER ---
        class VoxelBuilder {
            constructor(scene) {
                this.scene = scene;
                this.voxelSize = 1;
                this.geometries = [];
                this.materials = {};
                this.instances = {};

                // Base geometry for all voxels
                this.baseGeometry = new THREE.BoxGeometry(this.voxelSize, this.voxelSize, this.voxelSize);
            }

            getMaterial(color) {
                if (!this.materials[color]) {
                    this.materials[color] = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.8,
                        metalness: 0.1
                    });
                }
                return this.materials[color];
            }

            addVoxel(x, y, z, color) {
                // For a static scene, we can just create meshes. 
                // Optimization: In a real "engine" we'd use InstancedMesh, 
                // but for ~1000-2000 voxels, simple Meshes are fine and easier to code quickly with custom groups.
                const material = this.getMaterial(color);
                const mesh = new THREE.Mesh(this.baseGeometry, material);
                mesh.position.set(
                    x * this.voxelSize,
                    y * this.voxelSize,
                    z * this.voxelSize
                );
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.scene.add(mesh);
                return mesh;
            }

            // Helper to build a cuboid
            buildCuboid(startX, startY, startZ, width, height, depth, color) {
                for (let x = 0; x < width; x++) {
                    for (let y = 0; y < height; y++) {
                        for (let z = 0; z < depth; z++) {
                            this.addVoxel(startX + x, startY + y, startZ + z, color);
                        }
                    }
                }
            }
        }

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(COLORS.DARK_BLUE);
        scene.fog = new THREE.Fog(COLORS.DARK_BLUE, 20, 100);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 35);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 10, 0);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xFFCCAA, 0.6); // Warm ambient
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xAACCFF, 1); // Moon/Street light
        dirLight.position.set(20, 30, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -30;
        dirLight.shadow.camera.right = 30;
        dirLight.shadow.camera.top = 30;
        dirLight.shadow.camera.bottom = -30;
        scene.add(dirLight);

        // --- BUILDER ---
        const builder = new VoxelBuilder(scene);

        // --- ARCHITECTURE ---

        // Constants definition
        const PILLAR_HEIGHT = 16;
        const PILLAR_SPACING_MAIN = 14; // Space between central pillars
        const PILLAR_SPACING_SIDE = 8;  // Space between side pillars
        // Calculated positions
        const P1_X = - (PILLAR_SPACING_MAIN / 2 + PILLAR_SPACING_SIDE); // Leftmost
        const P2_X = - (PILLAR_SPACING_MAIN / 2); // Mid-Left
        const P3_X = (PILLAR_SPACING_MAIN / 2); // Mid-Right
        const P4_X = (PILLAR_SPACING_MAIN / 2 + PILLAR_SPACING_SIDE); // Rightmost

        function buildPillar(x, height) {
            // Stone base
            builder.buildCuboid(x - 1, 0, -1, 3, 2, 3, COLORS.STONE);
            // Red column
            builder.buildCuboid(x, 2, 0, 1, height, 1, COLORS.RED);
            // Top capital decoration (dougong placeholder)
            builder.buildCuboid(x - 1, 2 + height, 0, 3, 1, 1, COLORS.GREEN); // Horizontal bracket
            builder.buildCuboid(x, 2 + height, -1, 1, 1, 3, COLORS.GREEN); // Forward bracket
        }

        // Build 4 Pillars
        // Middle pillars are taller
        buildPillar(P2_X, PILLAR_HEIGHT);
        buildPillar(P3_X, PILLAR_HEIGHT);

        // Side pillars are slightly shorter
        buildPillar(P1_X, PILLAR_HEIGHT - 2);
        buildPillar(P4_X, PILLAR_HEIGHT - 2);

        // --- ROOF BUILDER ---
        function buildRoofTier(centerX, centerY, centerZ, width, depth, isMain) {
            // Roof structure
            const oddW = width % 2 !== 0;
            const steps = Math.floor(Math.min(width, depth) / 2) + 2; // Height of roof

            for (let y = 0; y < steps; y++) {
                let currentW = width + 2 - (y * 2);
                let currentD = depth + 2 - (y * 2);

                // Ridge line (topmost)
                if (currentW <= 0 || currentD <= 0) break;

                // Main roof body
                builder.buildCuboid(
                    centerX - Math.ceil(currentW / 2),
                    centerY + y,
                    centerZ - Math.ceil(currentD / 2),
                    currentW, 1, currentD,
                    COLORS.GOLD
                );

                // Eaves/Ridge decoration (optional, simplified)
            }

            // FLYING EAVES (Curved corners)
            // simple approximation: add extra voxels at corners moving up and out
            const cornerHeight = 3;
            const cornerOut = 2;

            const corners = [
                { dx: -1, dz: -1 }, // FL
                { dx: 1, dz: -1 },  // FR
                { dx: -1, dz: 1 },  // BL
                { dx: 1, dz: 1 }    // BR
            ];

            // Base dimensions for corners
            const baseW = width + 2;
            const baseD = depth + 2;
            const halfW = Math.ceil(baseW / 2);
            const halfD = Math.ceil(baseD / 2);

            corners.forEach(Corner => {
                for (let i = 0; i < 3; i++) {
                    // Extend out
                    let x = centerX + (Corner.dx * (halfW - 1 + i));
                    let z = centerZ + (Corner.dz * (halfD - 1 + i));
                    let y = centerY + i; // Curve up

                    // Place a few blocks to simulate the curve
                    builder.addVoxel(x, y, z, COLORS.GOLD);
                    // Add width to the curve
                    builder.addVoxel(x + (Corner.dx === 1 ? -1 : 1), y, z, COLORS.GOLD);
                    builder.addVoxel(x, y, z + (Corner.dz === 1 ? -1 : 1), COLORS.GOLD);
                }
            });
        }

        // --- BUILD ROOFS ---
        // Side Roof Left
        const sideRoofW = PILLAR_SPACING_SIDE + 4;
        const sideRoofD = 6;
        const sideRoofY = PILLAR_HEIGHT - 2 + 4; // Above the upper beam
        buildRoofTier(P1_X + (sideRoofW / 2) - 3, sideRoofY, 0, sideRoofW, sideRoofD, false);

        // Side Roof Right
        buildRoofTier(P4_X - (sideRoofW / 2) + 3, sideRoofY, 0, sideRoofW, sideRoofD, false);

        // Main Central Roof
        const mainRoofW = PILLAR_SPACING_MAIN + 8;
        const mainRoofD = 8;
        const mainRoofY = PILLAR_HEIGHT + 4;
        buildRoofTier(0, mainRoofY, 0, mainRoofW, mainRoofD, true);


        // --- SIGNBOARD ---
        // Center between main pillars, below the main roof
        const signW = 10;
        const signH = 3;
        const signY = PILLAR_HEIGHT + 1.5;
        builder.buildCuboid(-signW / 2, signY, -0.5, signW, signH, 1, COLORS.WOOD_DARK);

        // "å”" (Tang) - Simplified graphical representation
        // approximate patterns with Gold voxels
        function drawChar(startX, startY, grid) {
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < 5; x++) {
                    if (grid[y][x] === 1) {
                        builder.addVoxel(startX + x, startY + (4 - y), 0.5, COLORS.GOLD);
                    }
                }
            }
        }

        // 5x5 Grid patterns
        const charTang = [
            [0, 1, 1, 1, 0],
            [1, 0, 1, 0, 1],
            [1, 1, 1, 1, 1],
            [1, 0, 1, 0, 1],
            [1, 0, 1, 0, 1] // Very rough 'Tang'
        ];

        const charRen = [
            [0, 0, 1, 0, 0],
            [0, 1, 1, 1, 0],
            [0, 1, 0, 1, 0],
            [1, 0, 0, 0, 1],
            [1, 0, 0, 0, 1] // 'Ren'
        ];

        const charJie = [
            [0, 1, 1, 1, 0],
            [0, 0, 1, 0, 0],
            [1, 1, 1, 1, 1],
            [0, 1, 0, 1, 0],
            [0, 1, 0, 1, 0] // 'Jie' placeholder
        ];

        drawChar(-4, signY - 1, charTang);
        drawChar(-0.5, signY - 1, charRen);
        drawChar(3, signY - 1, charJie);


        // --- LINTELS (Beams) ---
        // Side beam left
        builder.buildCuboid(P1_X, PILLAR_HEIGHT - 2 + 1, 0, (P2_X - P1_X) + 1, 1, 1, COLORS.WHITE); // Lower beam
        builder.buildCuboid(P1_X, PILLAR_HEIGHT - 2 + 3, 0, (P2_X - P1_X) + 1, 1, 1, COLORS.RED); // Upper beam

        // Side beam right
        builder.buildCuboid(P3_X, PILLAR_HEIGHT - 2 + 1, 0, (P4_X - P3_X) + 1, 1, 1, COLORS.WHITE);
        builder.buildCuboid(P3_X, PILLAR_HEIGHT - 2 + 3, 0, (P4_X - P3_X) + 1, 1, 1, COLORS.RED);

        // Center beam (Main)
        builder.buildCuboid(P2_X, PILLAR_HEIGHT + 1, 0, (P3_X - P2_X) + 1, 1, 1, COLORS.WHITE);
        builder.buildCuboid(P2_X, PILLAR_HEIGHT + 3, 0, (P3_X - P2_X) + 1, 1, 1, COLORS.RED);

        // --- GROUND ---
        builder.buildCuboid(-30, -1, -20, 60, 1, 40, COLORS.PAVEMENT);

        // --- LANTERNS ---
        function buildLantern(x, y, z) {
            // String (rope)
            builder.addVoxel(x, y, z, COLORS.WHITE);

            // Lantern Body (Red center)
            const bodyY = y - 1;
            builder.buildCuboid(x - 1, bodyY - 1, z - 1, 3, 2, 3, COLORS.RED);
            builder.buildCuboid(x, bodyY - 2, z, 1, 4, 1, COLORS.RED); // core

            // Yellow/Gold highlights (top and bottom rims)
            builder.addVoxel(x, bodyY, z, COLORS.GOLD);
            builder.addVoxel(x, bodyY - 2, z, COLORS.GOLD);

            // Light
            const light = new THREE.PointLight(COLORS.GLOW_RED, 5, 20); // Red glow
            light.position.set(x, bodyY, z);
            scene.add(light);

            const bulb = new THREE.PointLight(COLORS.GLOW_YELLOW, 2, 10); // Inner warm core
            bulb.position.set(x, bodyY - 1, z);
            scene.add(bulb);
        }

        // Hang lanterns from the side beams
        buildLantern(P1_X + 2, PILLAR_HEIGHT - 2 + 1, 3); // Front Left Side
        buildLantern(P1_X + 2, PILLAR_HEIGHT - 2 + 1, -3); // Back Left Side
        buildLantern(P4_X - 2, PILLAR_HEIGHT - 2 + 1, 3); // Front Right Side
        buildLantern(P4_X - 2, PILLAR_HEIGHT - 2 + 1, -3); // Back Right Side

        // --- STONE LIONS (Simplified) ---
        function buildLion(x, z) {
            const y = 0;
            // Stone Pedestal
            builder.buildCuboid(x - 1, y, z - 1, 3, 2, 3, COLORS.STONE);

            // Lion Body (Sitting)
            const baseBodyY = y + 2;
            builder.buildCuboid(x, baseBodyY, z, 2, 2, 2, COLORS.WHITE); // Haunches
            // Chest/Head
            builder.buildCuboid(x, baseBodyY + 1, z + 1, 2, 3, 1, COLORS.WHITE);
            // Head detail
            builder.addVoxel(x, baseBodyY + 3, z + 1, COLORS.STONE); // Nose/Face
            builder.addVoxel(x - 0.5, baseBodyY + 3, z + 1, COLORS.GOLD); // Eye L
            builder.addVoxel(x + 0.5, baseBodyY + 3, z + 1, COLORS.GOLD); // Eye R
        }

        // Place Lions in front of the main pillars
        buildLion(P2_X, 3);
        buildLion(P3_X, 3);

        // --- BACKGROUND BUILDINGS ---
        // Simple silhouettes in the distance
        function buildBackgroundBuilding(x, z, w, h, d) {
            const color = (x % 2 === 0) ? 0x222244 : 0x333355; // Dark blocky colors
            builder.buildCuboid(x, 0, z, w, h, d, color);
            // Windows (randomly scattered glowing voxels)
            for (let i = 0; i < 10; i++) {
                let wx = x + Math.floor(Math.random() * w);
                let wy = Math.floor(Math.random() * (h - 2)) + 2;
                let wz = z + d; // front face
                if (Math.random() > 0.5) builder.addVoxel(wx, wy, wz, COLORS.GLOW_YELLOW);
            }
        }

        buildBackgroundBuilding(-25, -20, 10, 20, 5);
        buildBackgroundBuilding(-10, -25, 8, 25, 5);
        buildBackgroundBuilding(15, -22, 12, 18, 5);
        buildBackgroundBuilding(30, -20, 10, 15, 5);

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>