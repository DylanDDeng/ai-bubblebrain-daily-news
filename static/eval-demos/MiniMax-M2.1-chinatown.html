<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chinatown Paifang - Voxel Art</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: linear-gradient(180deg, #1a0a2e 0%, #16213e 50%, #0f3460 100%);
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffd700;
            font-family: 'SimSun', serif;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">唐人街 Chinatown</div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        // Camera
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 25);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 50;
        controls.target.set(0, 5, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xfff5e6, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xfffaf0, 1.2);
        sunLight.position.set(10, 20, 10);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // Materials
        const materials = {
            red: new THREE.MeshStandardMaterial({ color: 0xc41e3a, roughness: 0.7 }),
            darkRed: new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.8 }),
            gold: new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.8 }),
            darkGold: new THREE.MeshStandardMaterial({ color: 0xdaa520, roughness: 0.4, metalness: 0.6 }),
            white: new THREE.MeshStandardMaterial({ color: 0xfff8dc, roughness: 0.6 }),
            stone: new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9 }),
            darkStone: new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.9 }),
            wood: new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.8 }),
            lanternRed: new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.4, emissive: 0xff2222, emissiveIntensity: 0.3 }),
            lanternGlow: new THREE.MeshStandardMaterial({ color: 0xffffee, emissive: 0xffffaa, emissiveIntensity: 2 }),
            green: new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.8 }),
            black: new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.5 }),
            decoration: new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.2, metalness: 0.9 })
        };

        // Voxel helper function
        function createVoxel(x, y, z, material, scale = 0.5) {
            const geometry = new THREE.BoxGeometry(scale, scale, scale);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x * scale, y * scale, z * scale);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        // Create voxel column
        function createVoxelColumn(startX, startY, startZ, height, material, scale = 0.5) {
            const group = new THREE.Group();
            for (let y = 0; y < height; y++) {
                const voxel = createVoxel(startX, startY + y, startZ, material, scale);
                group.add(voxel);
            }
            return group;
        }

        // Create wall section
        function createWallSection(startX, startY, startZ, width, height, material, scale = 0.5) {
            const group = new THREE.Group();
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    const voxel = createVoxel(startX + x, startY + y, startZ, material, scale);
                    group.add(voxel);
                }
            }
            return group;
        }

        // Main Paifang group
        const paifang = new THREE.Group();

        // ==================== 4 RED PILLARS ====================
        const pillarHeight = 14;
        const pillarSpacing = 6;

        // Front pillars
        const frontLeftPillar = createVoxelColumn(-pillarSpacing/2, 0, 4, pillarHeight, materials.red);
        const frontRightPillar = createVoxelColumn(pillarSpacing/2, 0, 4, pillarHeight, materials.red);
        paifang.add(frontLeftPillar, frontRightPillar);

        // Back pillars
        const backLeftPillar = createVoxelColumn(-pillarSpacing/2, 0, -4, pillarHeight, materials.red);
        const backRightPillar = createVoxelColumn(pillarSpacing/2, 0, -4, pillarHeight, materials.red);
        paifang.add(backLeftPillar, backRightPillar);

        // Add decorative rings around pillars
        function addPillarRings(pillarGroup, spacing = 4) {
            for (let y = spacing; y < pillarHeight; y += spacing) {
                const ringGeo = new THREE.BoxGeometry(0.6, 0.2, 0.6);
                const ringMat = materials.darkGold;

                const ring1 = new THREE.Mesh(ringGeo, ringMat);
                ring1.position.set(0, y * 0.5, 0);
                pillarGroup.add(ring1);
            }
        }
        addPillarRings(frontLeftPillar);
        addPillarRings(frontRightPillar);
        addPillarRings(backLeftPillar);
        addPillarRings(backRightPillar);

        // ==================== ROOF TIERS ====================
        function createRoofTier(width, height, yOffset, material, darkMaterial) {
            const group = new THREE.Group();

            // Base of roof tier
            for (let x = 0; x < width; x++) {
                for (let z = -3; z <= 3; z++) {
                    const voxel = createVoxel(x - width/2 + 0.5, yOffset, z, material);
                    group.add(voxel);
                }
            }

            // Eaves - upturned corners
            const cornerEaves = [
                [-width/2 - 1, yOffset, -3], [-width/2 - 1, yOffset, 3],
                [width/2, yOffset, -3], [width/2, yOffset, 3]
            ];

            cornerEaves.forEach(([x, y, z]) => {
                // Upturned corner
                for (let i = 0; i < 3; i++) {
                    const voxel = createVoxel(x - (x < 0 ? -i : i), y + i * 0.5, z, darkMaterial);
                    group.add(voxel);
                }
            });

            // Decorative edge
            for (let z = -3; z <= 3; z++) {
                const voxel = createVoxel(-width/2 - 1, yOffset + 0.5, z, darkMaterial);
                group.add(voxel);
                const voxel2 = createVoxel(width/2, yOffset + 0.5, z, darkMaterial);
                group.add(voxel2);
            }

            return group;
        }

        // Tier 1 (bottom) - widest
        const tier1 = createRoofTier(12, 2, pillarHeight + 1, materials.gold, materials.darkGold);
        paifang.add(tier1);

        // Tier 2 (middle)
        const tier2 = createRoofTier(10, 2, pillarHeight + 4, materials.gold, materials.darkGold);
        paifang.add(tier2);

        // Tier 3 (top) - narrowest
        const tier3 = createRoofTier(8, 2, pillarHeight + 7, materials.gold, materials.darkGold);
        paifang.add(tier3);

        // Top ornament (火焰珠)
        const topOrnament = createVoxel(0, pillarHeight + 9, 0, materials.decoration);
        paifang.add(topOrnament);

        // ==================== CENTRAL SIGNBOARD ====================
        function createChineseChar(char, x, y, z, color) {
            const group = new THREE.Group();

            // Simple voxel representation of Chinese characters
            const patterns = {
                '唐': [
                    [1,0,1,0,1], [1,0,1,0,1], [1,1,1,1,1], [0,0,1,0,0], [0,0,1,0,0]
                ],
                '人': [
                    [0,1,0], [1,0,1], [0,1,0], [0,1,0], [0,1,0]
                ],
                '街': [
                    [1,0,1,0,1], [1,1,1,1,1], [0,0,1,0,0], [0,1,0,1,0], [1,0,0,0,1]
                ],
                '中': [
                    [0,1,0], [0,1,0], [1,1,1], [0,1,0], [0,1,0]
                ],
                '华': [
                    [1,0,1,0,1], [0,1,1,1,0], [0,0,1,0,0], [0,1,0,1,0], [1,0,0,0,1]
                ]
            };

            const pattern = patterns[char] || [];
            const charMaterial = new THREE.MeshStandardMaterial({
                color: color || 0xffd700,
                emissive: color || 0xffd700,
                emissiveIntensity: 0.2
            });

            pattern.forEach((row, ry) => {
                row.forEach((cell, rx) => {
                    if (cell) {
                        const voxel = createVoxel(rx - 2, -ry + 2, 0, charMaterial);
                        group.add(voxel);
                    }
                });
            });

            group.position.set(x, y, z);
            return group;
        }

        // Signboard frame
        const signboardGroup = new THREE.Group();
        for (let x = -3; x <= 3; x++) {
            signboardGroup.add(createVoxel(x, 10, 3, materials.red));
            signboardGroup.add(createVoxel(x, 10, -3, materials.red));
        }
        for (let z = -3; z <= 3; z++) {
            signboardGroup.add(createVoxel(-3, 10, z, materials.red));
            signboardGroup.add(createVoxel(3, 10, z, materials.red));
            signboardGroup.add(createVoxel(-3, 13, z, materials.red));
            signboardGroup.add(createVoxel(3, 13, z, materials.red));
        }
        // Fill top and bottom
        for (let x = -2; x <= 2; x++) {
            signboardGroup.add(createVoxel(x, 10, 2, materials.white));
            signboardGroup.add(createVoxel(x, 10, 1, materials.white));
            signboardGroup.add(createVoxel(x, 10, 0, materials.white));
            signboardGroup.add(createVoxel(x, 10, -1, materials.white));
            signboardGroup.add(createVoxel(x, 10, -2, materials.white));
        }
        // Posts for signboard
        for (let y = 6; y < 10; y++) {
            signboardGroup.add(createVoxel(-2, y, 0, materials.red));
            signboardGroup.add(createVoxel(2, y, 0, materials.red));
        }

        // Add Chinese characters - 唐人街
        const chars = [
            createChineseChar('唐', -1.5, 10.5, 3.1, 0xffd700),
            createChineseChar('人', -0.5, 10.5, 3.1, 0xffd700),
            createChineseChar('街', 0.5, 10.5, 3.1, 0xffd700),
            createChineseChar('中', 1.5, 10.5, 3.1, 0xffd700),
            createChineseChar('华', -1, 10.5, -3.1, 0xffd700),
        ];
        chars.forEach(c => signboardGroup.add(c));

        paifang.add(signboardGroup);

        // ==================== DECORATIVE ELEMENTS ====================

        // Dragon carvings on pillars (simplified voxel dragons)
        function createDragonHead(x, y, z, facingOut = true) {
            const group = new THREE.Group();
            const dir = facingOut ? 1 : -1;

            // Head
            group.add(createVoxel(x, y, z, materials.gold));
            group.add(createVoxel(x, y + 0.5, z, materials.gold));
            group.add(createVoxel(x, y - 0.5, z, materials.gold));
            // Snout
            group.add(createVoxel(x + 0.5 * dir, y, z, materials.gold));
            // Eyes
            group.add(createVoxel(x + 0.3 * dir, y + 0.3, z + 0.3, materials.black));
            group.add(createVoxel(x + 0.3 * dir, y + 0.3, z - 0.3, materials.black));
            // Horns
            group.add(createVoxel(x, y + 1, z, materials.gold));
            group.add(createVoxel(x + 0.2 * dir, y + 1.3, z, materials.gold));

            return group;
        }

        // Add dragons to front of front pillars
        paifang.add(createDragonHead(-pillarSpacing/2 - 1, 8, 4, false));
        paifang.add(createDragonHead(pillarSpacing/2 + 1, 8, 4, true));
        paifang.add(createDragonHead(-pillarSpacing/2 - 1, 8, -4, false));
        paifang.add(createDragonHead(pillarSpacing/2 + 1, 8, -4, true));

        // Cloud patterns under roof
        function createCloud(x, y, z) {
            const group = new THREE.Group();
            const cloudMaterial = materials.white;

            const cloudPattern = [
                [0,1,0,1,0],
                [1,1,1,1,1],
                [0,1,1,1,0]
            ];

            cloudPattern.forEach((row, ry) => {
                row.forEach((cell, rx) => {
                    if (cell) {
                        group.add(createVoxel(rx - 2, -ry, 0, cloudMaterial));
                    }
                });
            });

            group.position.set(x, y, z);
            return group;
        }

        // Add clouds
        for (let i = 0; i < 3; i++) {
            paifang.add(createCloud(-3, pillarHeight + 0.5, 0));
            paifang.add(createCloud(3, pillarHeight + 0.5, 0));
        }

        // ==================== RED LANTERNS ====================
        function createLantern(x, y, z) {
            const group = new THREE.Group();

            // Main lantern body
            const lanternBody = createVoxel(0, 0, 0, materials.lanternRed);
            lanternBody.scale.set(1, 1.2, 1);
            group.add(lanternBody);

            // Top cap
            group.add(createVoxel(0, 0.7, 0, materials.gold));
            group.add(createVoxel(0, 0.85, 0, materials.gold));

            // Bottom cap
            group.add(createVoxel(0, -0.7, 0, materials.gold));
            group.add(createVoxel(0, -0.85, 0, materials.gold));

            // Decorative fringe
            for (let i = -2; i <= 2; i++) {
                group.add(createVoxel(i * 0.15, -1, 0, materials.gold));
                group.add(createVoxel(i * 0.15, -1.2, 0, materials.gold));
            }

            // Glow effect
            const glowGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const glow = new THREE.Mesh(glowGeo, materials.lanternGlow);
            glow.position.set(0, 0, 0);
            group.add(glow);

            // Point light for lantern glow
            const light = new THREE.PointLight(0xff6644, 0.5, 5);
            light.position.set(0, 0, 0);
            group.add(light);

            group.position.set(x, y, z);
            return group;
        }

        // Add lanterns on both sides (at least 4)
        const lanterns = [
            createLantern(-pillarSpacing/2 - 2, 11, 0),
            createLantern(-pillarSpacing/2 - 2, 11, 3),
            createLantern(-pillarSpacing/2 - 2, 11, -3),
            createLantern(pillarSpacing/2 + 2, 11, 0),
            createLantern(pillarSpacing/2 + 2, 11, 3),
            createLantern(pillarSpacing/2 + 2, 11, -3),
            createLantern(0, 12, 5),
            createLantern(0, 12, -5),
        ];
        lanterns.forEach(l => paifang.add(l));

        // ==================== STONE LION STATUES ====================
        function createStoneLion(x, y, z, facingRight = true) {
            const group = new THREE.Group();
            const dir = facingRight ? 1 : -1;
            const s = 0.4; // scale

            // Base/pedestal
            for (let bx = -1; bx <= 1; bx++) {
                group.add(createVoxel(bx, 0, 0, materials.darkStone, s));
            }
            for (let bx = -1; bx <= 1; bx++) {
                for (let by = 0; by < 2; by++) {
                    group.add(createVoxel(bx, by + 1, 0, materials.stone, s));
                }
            }

            // Body
            for (let by = 2; by < 5; by++) {
                group.add(createVoxel(0, by, 0, materials.stone, s));
            }

            // Head
            group.add(createVoxel(dir * 0.5, 5.5, 0, materials.stone, s));
            group.add(createVoxel(dir * 0.5, 5, 0, materials.stone, s));
            group.add(createVoxel(0, 5.5, 0, materials.stone, s));

            // Eyes
            group.add(createVoxel(dir * 0.7, 5.8, 0.3, materials.black, s * 0.5));
            group.add(createVoxel(dir * 0.7, 5.8, -0.3, materials.black, s * 0.5));

            // Nose/Mouth
            group.add(createVoxel(dir * 0.8, 5.3, 0, materials.black, s * 0.5));

            // Mane
            for (let mx = -1; mx <= 1; mx++) {
                group.add(createVoxel(mx * 0.3, 5, 0.5, materials.gold, s));
                group.add(createVoxel(mx * 0.3, 5, -0.5, materials.gold, s));
            }

            // Front legs (seated pose)
            group.add(createVoxel(dir * 0.5, 2, 1, materials.stone, s));
            group.add(createVoxel(dir * 0.5, 2, -1, materials.stone, s));

            group.position.set(x, y, z);
            return group;
        }

        // Add stone lions at base
        paifang.add(createStoneLion(-pillarSpacing/2 - 1.5, 0, 6, true));
        paifang.add(createStoneLion(pillarSpacing/2 + 1.5, 0, 6, false));
        paifang.add(createStoneLion(-pillarSpacing/2 - 1.5, 0, -6, true));
        paifang.add(createStoneLion(pillarSpacing/2 + 1.5, 0, -6, false));

        // ==================== BASE/FOUNDATION ====================
        const foundation = new THREE.Group();

        // Main platform
        for (let x = -8; x <= 8; x++) {
            for (let z = -8; z <= 8; z++) {
                if (Math.abs(x) <= pillarSpacing/2 + 1 || Math.abs(z) <= 5) {
                    foundation.add(createVoxel(x, 0, z, materials.stone));
                }
            }
        }

        // Step up
        for (let x = -7; x <= 7; x++) {
            for (let z = -7; z <= 7; z++) {
                if (Math.abs(x) <= pillarSpacing/2 + 2 || Math.abs(z) <= 6) {
                    foundation.add(createVoxel(x, 1, z, materials.darkStone));
                }
            }
        }

        paifang.add(foundation);

        // ==================== BACKGROUND - SIMPLE STREET ====================
        const street = new THREE.Group();

        // Background buildings (simplified)
        function createBuilding(x, y, z, width, height, color) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 });

            for (let bx = 0; bx < width; bx++) {
                for (let by = 0; by < height; by++) {
                    group.add(createVoxel(bx, by, 0, mat));
                }
            }

            // Roof
            for (let rx = -1; rx <= width; rx++) {
                group.add(createVoxel(rx - 0.5, height, 0, materials.darkGold));
            }

            group.position.set(x, y, z);
            return group;
        }

        // Buildings behind the gate
        street.add(createBuilding(-15, 1, -15, 4, 6, 0xd4a574));
        street.add(createBuilding(-10, 1, -18, 5, 8, 0xc4a67c));
        street.add(createBuilding(-4, 1, -20, 4, 5, 0xb8956b));
        street.add(createBuilding(4, 1, -20, 4, 7, 0xc9a87c));
        street.add(createBuilding(10, 1, -18, 5, 6, 0xd4b896));
        street.add(createBuilding(16, 1, -15, 4, 8, 0xbd9b73));

        // Add some trees
        function createTree(x, y, z) {
            const group = new THREE.Group();

            // Trunk
            for (let ty = 0; ty < 4; ty++) {
                group.add(createVoxel(0, ty, 0, materials.wood));
            }

            // Leaves
            for (let lx = -1; lx <= 1; lx++) {
                for (let ly = 3; ly <= 5; ly++) {
                    for (let lz = -1; lz <= 1; lz++) {
                        if (Math.random() > 0.2) {
                            group.add(createVoxel(lx, ly, lz, materials.green));
                        }
                    }
                }
            }

            group.position.set(x, y, z);
            return group;
        }

        street.add(createTree(-12, 0, -12));
        street.add(createTree(12, 0, -12));
        street.add(createTree(-8, 0, -16));
        street.add(createTree(8, 0, -16));

        scene.add(street);

        // ==================== ADD PAIFANG TO SCENE ====================
        scene.add(paifang);

        // ==================== ANIMATION LOOP ====================
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            // Lantern flicker effect
            lanterns.forEach((lantern, i) => {
                const light = lantern.children.find(c => c.isPointLight);
                if (light) {
                    light.intensity = 0.5 + Math.sin(time * 3 + i) * 0.15;
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
