<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸Šæµ·ä½“ç´ è‰ºæœ¯ - Shanghai Voxel Art</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: linear-gradient(to bottom, #0a0a1a 0%, #1a1a3a 50%, #2a1a2a 100%);
            font-family: 'Arial', sans-serif;
        }
        #canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            text-shadow: 0 0 10px rgba(0,200,255,0.8);
            pointer-events: none;
            z-index: 100;
        }
        #title {
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(90deg, #ff6b6b, #ffd93d, #6bcb77, #4d96ff, #ff6b6b);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient 3s linear infinite;
        }
        @keyframes gradient {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.7);
            font-size: 12px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            text-shadow: 0 0 20px #00ffff;
        }
    </style>
</head>
<body>
    <div id="info">
        <div id="title">ä¸Šæµ· Â· ä½“ç´ ä¹‹åŸ</div>
        <div>Shanghai Voxel Cityscape</div>
    </div>
    <div id="controls">ğŸ–±ï¸ æ‹–æ‹½æ—‹è½¬ | æ»šè½®ç¼©æ”¾ | è‡ªåŠ¨æ—‹è½¬ä¸­...</div>
    <div id="loading">æ„å»ºä½“ç´ ä¸–ç•Œä¸­...</div>
    <canvas id="canvas"></canvas>

    <script>
        // ============ Three.js æ ¸å¿ƒä»£ç å†…è” (ç®€åŒ–ç‰ˆ) ============
        // ä½¿ç”¨åŸç”ŸWebGLå®ç°ä½“ç´ æ¸²æŸ“

        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
        const loading = document.getElementById('loading');

        if (!gl) {
            loading.textContent = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWebGL';
            throw new Error('WebGL not supported');
        }

        // è®¾ç½®ç”»å¸ƒå¤§å°
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resize();
        window.addEventListener('resize', resize);

        // ç€è‰²å™¨
        const vertexShaderSource = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;
            attribute vec3 aColor;
            attribute vec3 aOffset;

            uniform mat4 uProjection;
            uniform mat4 uView;
            uniform mat4 uModel;

            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vPosition;

            void main() {
                vec3 pos = aPosition + aOffset;
                vec4 worldPos = uModel * vec4(pos, 1.0);
                gl_Position = uProjection * uView * worldPos;
                vColor = aColor;
                vNormal = mat3(uModel) * aNormal;
                vPosition = worldPos.xyz;
            }
        `;

        const fragmentShaderSource = `
            precision highp float;

            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vPosition;

            uniform vec3 uLightDir;
            uniform vec3 uLightDir2;
            uniform float uTime;

            void main() {
                vec3 normal = normalize(vNormal);

                // ä¸»å…‰æº
                float diff = max(dot(normal, normalize(uLightDir)), 0.0);
                // è¡¥å…‰
                float diff2 = max(dot(normal, normalize(uLightDir2)), 0.0) * 0.3;
                // ç¯å¢ƒå…‰
                float ambient = 0.25;

                // è¾¹ç¼˜å…‰
                vec3 viewDir = normalize(-vPosition);
                float rim = 1.0 - max(dot(viewDir, normal), 0.0);
                rim = pow(rim, 3.0) * 0.4;

                vec3 color = vColor * (ambient + diff * 0.7 + diff2);
                color += rim * vec3(0.3, 0.5, 1.0);

                // é«˜åº¦é›¾æ•ˆ
                float fog = smoothstep(-50.0, 100.0, vPosition.y) * 0.3 + 0.7;
                color *= fog;

                // åŸå¸‚ç¯å…‰é—ªçƒæ•ˆæœ
                float flicker = sin(uTime * 3.0 + vPosition.x * 0.1 + vPosition.z * 0.1) * 0.5 + 0.5;
                if (vColor.r > 0.8 || vColor.g > 0.8 || vColor.b > 0.8) {
                    color += vColor * flicker * 0.3;
                }

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // ç¼–è¯‘ç€è‰²å™¨
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // è·å–ç€è‰²å™¨å˜é‡ä½ç½®
        const aPosition = gl.getAttribLocation(program, 'aPosition');
        const aNormal = gl.getAttribLocation(program, 'aNormal');
        const aColor = gl.getAttribLocation(program, 'aColor');
        const aOffset = gl.getAttribLocation(program, 'aOffset');
        const uProjection = gl.getUniformLocation(program, 'uProjection');
        const uView = gl.getUniformLocation(program, 'uView');
        const uModel = gl.getUniformLocation(program, 'uModel');
        const uLightDir = gl.getUniformLocation(program, 'uLightDir');
        const uLightDir2 = gl.getUniformLocation(program, 'uLightDir2');
        const uTime = gl.getUniformLocation(program, 'uTime');

        // ä½“ç´ ç«‹æ–¹ä½“é¡¶ç‚¹æ•°æ®
        const cubeVertices = new Float32Array([
            // å‰é¢
            -0.5, -0.5,  0.5,  0, 0, 1,
             0.5, -0.5,  0.5,  0, 0, 1,
             0.5,  0.5,  0.5,  0, 0, 1,
            -0.5,  0.5,  0.5,  0, 0, 1,
            // åé¢
            -0.5, -0.5, -0.5,  0, 0, -1,
            -0.5,  0.5, -0.5,  0, 0, -1,
             0.5,  0.5, -0.5,  0, 0, -1,
             0.5, -0.5, -0.5,  0, 0, -1,
            // ä¸Šé¢
            -0.5,  0.5, -0.5,  0, 1, 0,
            -0.5,  0.5,  0.5,  0, 1, 0,
             0.5,  0.5,  0.5,  0, 1, 0,
             0.5,  0.5, -0.5,  0, 1, 0,
            // ä¸‹é¢
            -0.5, -0.5, -0.5,  0, -1, 0,
             0.5, -0.5, -0.5,  0, -1, 0,
             0.5, -0.5,  0.5,  0, -1, 0,
            -0.5, -0.5,  0.5,  0, -1, 0,
            // å³é¢
             0.5, -0.5, -0.5,  1, 0, 0,
             0.5,  0.5, -0.5,  1, 0, 0,
             0.5,  0.5,  0.5,  1, 0, 0,
             0.5, -0.5,  0.5,  1, 0, 0,
            // å·¦é¢
            -0.5, -0.5, -0.5, -1, 0, 0,
            -0.5, -0.5,  0.5, -1, 0, 0,
            -0.5,  0.5,  0.5, -1, 0, 0,
            -0.5,  0.5, -0.5, -1, 0, 0,
        ]);

        const cubeIndices = new Uint16Array([
            0, 1, 2, 0, 2, 3,
            4, 5, 6, 4, 6, 7,
            8, 9, 10, 8, 10, 11,
            12, 13, 14, 12, 14, 15,
            16, 17, 18, 16, 18, 19,
            20, 21, 22, 20, 22, 23
        ]);

        // åˆ›å»ºç«‹æ–¹ä½“ç¼“å†²åŒº
        const cubeVBO = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBO);
        gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

        const cubeEBO = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeEBO);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

        // ============ ä¸Šæµ·å»ºç­‘ç”Ÿæˆ ============
        const voxels = [];

        // é¢œè‰²å®šä¹‰
        const colors = {
            // ä¸œæ–¹æ˜ç å¡”
            pearlPink: [1.0, 0.4, 0.6],
            pearlRed: [0.9, 0.2, 0.3],
            pearlWhite: [0.95, 0.95, 1.0],
            pearlGold: [1.0, 0.85, 0.3],

            // ä¸Šæµ·ä¸­å¿ƒ
            centerBlue: [0.3, 0.6, 0.9],
            centerTeal: [0.2, 0.8, 0.8],
            centerGlass: [0.5, 0.7, 0.9],

            // é‡‘èŒ‚å¤§å¦
            jinmaoGold: [0.85, 0.7, 0.3],
            jinmaoBrown: [0.6, 0.5, 0.3],
            jinmaoSilver: [0.8, 0.8, 0.85],

            // ç¯çƒé‡‘èä¸­å¿ƒ
            swfcBlue: [0.2, 0.3, 0.5],
            swfcGlass: [0.4, 0.5, 0.7],
            swfcLight: [0.8, 0.9, 1.0],

            // å¤–æ»©å»ºç­‘
            bundStone: [0.9, 0.85, 0.75],
            bundBrick: [0.75, 0.5, 0.4],
            bundGreen: [0.3, 0.6, 0.4],
            bundGold: [0.95, 0.8, 0.4],

            // ç°ä»£å»ºç­‘
            modernGlass: [0.4, 0.6, 0.8],
            modernSteel: [0.6, 0.65, 0.7],
            modernWhite: [0.9, 0.92, 0.95],

            // è£…é¥°
            neonPink: [1.0, 0.2, 0.6],
            neonBlue: [0.2, 0.6, 1.0],
            neonGreen: [0.2, 1.0, 0.5],
            neonYellow: [1.0, 1.0, 0.3],
            neonPurple: [0.7, 0.3, 1.0],

            // ç¯å¢ƒ
            water: [0.1, 0.3, 0.5],
            waterLight: [0.2, 0.5, 0.7],
            ground: [0.15, 0.15, 0.2],
            road: [0.2, 0.2, 0.25],
            grass: [0.2, 0.5, 0.3],
            tree: [0.15, 0.4, 0.2],
        };

        function addVoxel(x, y, z, color) {
            voxels.push({ x, y, z, color });
        }

        function addBox(x, y, z, w, h, d, color) {
            for (let dx = 0; dx < w; dx++) {
                for (let dy = 0; dy < h; dy++) {
                    for (let dz = 0; dz < d; dz++) {
                        addVoxel(x + dx, y + dy, z + dz, color);
                    }
                }
            }
        }

        function addHollowBox(x, y, z, w, h, d, color) {
            for (let dx = 0; dx < w; dx++) {
                for (let dy = 0; dy < h; dy++) {
                    for (let dz = 0; dz < d; dz++) {
                        if (dx === 0 || dx === w-1 || dy === 0 || dy === h-1 || dz === 0 || dz === d-1) {
                            addVoxel(x + dx, y + dy, z + dz, color);
                        }
                    }
                }
            }
        }

        function addCylinder(cx, y, cz, radius, height, color, hollow = false) {
            for (let dy = 0; dy < height; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dz = -radius; dz <= radius; dz++) {
                        const dist = Math.sqrt(dx*dx + dz*dz);
                        if (hollow) {
                            if (dist <= radius && dist >= radius - 1) {
                                addVoxel(cx + dx, y + dy, cz + dz, color);
                            }
                        } else {
                            if (dist <= radius) {
                                addVoxel(cx + dx, y + dy, cz + dz, color);
                            }
                        }
                    }
                }
            }
        }

        function addSphere(cx, cy, cz, radius, color) {
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dz = -radius; dz <= radius; dz++) {
                        if (dx*dx + dy*dy + dz*dz <= radius*radius) {
                            addVoxel(cx + dx, cy + dy, cz + dz, color);
                        }
                    }
                }
            }
        }

        // ä¸œæ–¹æ˜ç å¡”
        function createOrientalPearlTower(baseX, baseZ) {
            const x = baseX, z = baseZ;

            // åº•åº§
            addCylinder(x, 0, z, 6, 3, colors.pearlWhite);

            // ä¸‰ä¸ªæ”¯æ’‘æŸ±
            const legOffset = 5;
            for (let angle = 0; angle < 3; angle++) {
                const ax = x + Math.cos(angle * Math.PI * 2 / 3) * legOffset;
                const az = z + Math.sin(angle * Math.PI * 2 / 3) * legOffset;

                // æ–œè…¿
                for (let h = 0; h < 25; h++) {
                    const t = h / 25;
                    const lx = ax * (1 - t) + x * t;
                    const lz = az * (1 - t) + z * t;
                    addCylinder(Math.round(lx), 3 + h, Math.round(lz), 1, 1, colors.pearlPink);
                }
            }

            // ä¸‹çƒä½“
            addSphere(x, 30, z, 7, colors.pearlPink);
            addSphere(x, 30, z, 5, colors.pearlRed);

            // ä¸­é—´æ”¯æŸ±
            addCylinder(x, 37, z, 2, 20, colors.pearlWhite);

            // ä¸­çƒä½“
            addSphere(x, 60, z, 5, colors.pearlPink);
            addSphere(x, 60, z, 3, colors.pearlRed);

            // ä¸Šæ”¯æŸ±
            addCylinder(x, 65, z, 2, 25, colors.pearlWhite);

            // ä¸Šçƒä½“
            addSphere(x, 92, z, 4, colors.pearlPink);

            // é¡¶éƒ¨å°–å¡”
            for (let h = 0; h < 20; h++) {
                const r = Math.max(0, 2 - h * 0.1);
                if (r > 0) addCylinder(x, 96 + h, z, Math.round(r), 1, colors.pearlGold);
                else addVoxel(x, 96 + h, z, colors.pearlGold);
            }

            // è£…é¥°ç¯å¸¦
            for (let h = 25; h < 35; h += 2) {
                addCylinder(x, h, z, 8, 1, colors.neonPink, true);
            }
        }

        // ä¸Šæµ·ä¸­å¿ƒå¤§å¦
        function createShanghaiTower(baseX, baseZ) {
            const x = baseX, z = baseZ;
            const height = 130;

            for (let h = 0; h < height; h++) {
                // æ‰­è½¬æ•ˆæœ
                const twist = h * 0.02;
                const scale = 1 - h * 0.003;
                const size = Math.max(2, Math.floor(8 * scale));

                for (let dx = -size; dx <= size; dx++) {
                    for (let dz = -size; dz <= size; dz++) {
                        // ä¸‰è§’å½¢æˆªé¢æ—‹è½¬
                        const rx = dx * Math.cos(twist) - dz * Math.sin(twist);
                        const rz = dx * Math.sin(twist) + dz * Math.cos(twist);

                        // åˆ›å»ºåœ†è§’ä¸‰è§’å½¢
                        const dist = Math.sqrt(rx*rx + rz*rz);
                        if (dist <= size) {
                            let color;
                            if (h % 15 < 2) {
                                color = colors.centerTeal;
                            } else if (dist > size - 1) {
                                color = colors.centerGlass;
                            } else {
                                color = colors.centerBlue;
                            }
                            addVoxel(x + dx, h, z + dz, color);
                        }
                    }
                }
            }

            // é¡¶éƒ¨
            addCylinder(x, height, z, 2, 10, colors.centerTeal);
            addVoxel(x, height + 10, z, colors.neonBlue);
        }

        // é‡‘èŒ‚å¤§å¦
        function createJinMaoTower(baseX, baseZ) {
            const x = baseX, z = baseZ;
            const height = 95;

            // ä¸»ä½“ - é˜¶æ¢¯å¼ç»“æ„
            let currentSize = 7;
            let currentH = 0;

            while (currentH < height && currentSize > 1) {
                const sectionHeight = Math.min(12, height - currentH);

                // ä¸»ä½“
                for (let h = 0; h < sectionHeight; h++) {
                    for (let dx = -currentSize; dx <= currentSize; dx++) {
                        for (let dz = -currentSize; dz <= currentSize; dz++) {
                            let color;
                            if (Math.abs(dx) === currentSize || Math.abs(dz) === currentSize) {
                                color = h % 3 === 0 ? colors.jinmaoGold : colors.jinmaoBrown;
                            } else {
                                color = colors.jinmaoSilver;
                            }
                            addVoxel(x + dx, currentH + h, z + dz, color);
                        }
                    }
                }

                currentH += sectionHeight;
                currentSize = Math.max(1, currentSize - 1);
            }

            // é¡¶éƒ¨å°–å¡”
            for (let h = 0; h < 15; h++) {
                addVoxel(x, height + h, z, colors.jinmaoGold);
                if (h < 5) {
                    addVoxel(x + 1, height + h, z, colors.jinmaoGold);
                    addVoxel(x - 1, height + h, z, colors.jinmaoGold);
                    addVoxel(x, height + h, z + 1, colors.jinmaoGold);
                    addVoxel(x, height + h, z - 1, colors.jinmaoGold);
                }
            }
        }

        // ç¯çƒé‡‘èä¸­å¿ƒ
        function createSWFC(baseX, baseZ) {
            const x = baseX, z = baseZ;
            const height = 105;

            for (let h = 0; h < height; h++) {
                const t = h / height;
                const widthX = Math.floor(5 + 3 * (1 - t));
                const widthZ = Math.floor(3 + 2 * (1 - t));

                // å¼€ç“¶å™¨å½¢çŠ¶çš„å­”
                const holeStart = 85;
                const holeEnd = 100;
                const isHole = h >= holeStart && h < holeEnd;

                for (let dx = -widthX; dx <= widthX; dx++) {
                    for (let dz = -widthZ; dz <= widthZ; dz++) {
                        // æ£€æŸ¥æ˜¯å¦åœ¨å­”å†…
                        if (isHole && Math.abs(dx) < 3 && Math.abs(dz) < widthZ) {
                            continue;
                        }

                        let color;
                        if (Math.abs(dx) === widthX || Math.abs(dz) === widthZ) {
                            color = colors.swfcBlue;
                        } else if (h % 10 < 1) {
                            color = colors.swfcLight;
                        } else {
                            color = colors.swfcGlass;
                        }
                        addVoxel(x + dx, h, z + dz, color);
                    }
                }
            }
        }

        // å¤–æ»©å»ºç­‘ç¾¤
        function createBundBuildings(startX, z) {
            // å¤šæ ‹æ¬§å¼å»ºç­‘
            const buildings = [
                { w: 8, h: 25, d: 6, style: 'classic' },
                { w: 6, h: 30, d: 5, style: 'dome' },
                { w: 10, h: 22, d: 7, style: 'clock' },
                { w: 7, h: 28, d: 5, style: 'classic' },
                { w: 9, h: 35, d: 6, style: 'tower' },
                { w: 6, h: 24, d: 5, style: 'classic' },
            ];

            let currentX = startX;

            buildings.forEach((b, i) => {
                const x = currentX;

                // ä¸»ä½“
                for (let h = 0; h < b.h; h++) {
                    for (let dx = 0; dx < b.w; dx++) {
                        for (let dz = 0; dz < b.d; dz++) {
                            let color;
                            const isEdge = dx === 0 || dx === b.w-1 || dz === 0 || dz === b.d-1;
                            const isWindow = (dx % 2 === 1) && (h % 4 >= 1 && h % 4 <= 2);

                            if (isEdge) {
                                color = colors.bundStone;
                            } else if (isWindow) {
                                color = colors.neonYellow;
                            } else {
                                color = i % 2 === 0 ? colors.bundBrick : colors.bundStone;
                            }
                            addVoxel(x + dx, h, z + dz, color);
                        }
                    }
                }

                // å±‹é¡¶è£…é¥°
                if (b.style === 'dome') {
                    addSphere(x + b.w/2, b.h + 3, z + b.d/2, 4, colors.bundGreen);
                } else if (b.style === 'clock') {
                    addBox(x + 2, b.h, z + 1, 4, 6, 3, colors.bundStone);
                    addSphere(x + b.w/2, b.h + 4, z + b.d/2, 2, colors.bundGold);
                } else if (b.style === 'tower') {
                    for (let h = 0; h < 10; h++) {
                        const r = Math.max(1, 3 - Math.floor(h/3));
                        addCylinder(x + b.w/2, b.h + h, z + b.d/2, r, 1, colors.bundGold);
                    }
                } else {
                    // ç®€å•çš„ä¸‰è§’å±‹é¡¶
                    for (let h = 0; h < 4; h++) {
                        addBox(x + h, b.h + h, z, b.w - h*2, 1, b.d, colors.bundBrick);
                    }
                }

                currentX += b.w + 2;
            });
        }

        // ç°ä»£å»ºç­‘ç¾¤
        function createModernBuildings(startX, z) {
            const heights = [45, 60, 35, 55, 70, 40, 50, 65];

            heights.forEach((h, i) => {
                const x = startX + i * 12;
                const w = 4 + Math.random() * 3;
                const d = 4 + Math.random() * 3;

                for (let y = 0; y < h; y++) {
                    for (let dx = 0; dx < w; dx++) {
                        for (let dz = 0; dz < d; dz++) {
                            let color;
                            const isGlass = y % 8 < 6;
                            const isEdge = dx === 0 || dx === Math.floor(w)-1 || dz === 0 || dz === Math.floor(d)-1;

                            if (isEdge) {
                                color = colors.modernSteel;
                            } else if (isGlass && Math.random() > 0.3) {
                                color = Math.random() > 0.8 ? colors.neonYellow : colors.modernGlass;
                            } else {
                                color = colors.modernWhite;
                            }
                            addVoxel(Math.floor(x + dx), y, Math.floor(z + dz), color);
                        }
                    }
                }

                // å±‹é¡¶è®¾å¤‡
                addBox(Math.floor(x + 1), h, Math.floor(z + 1), 2, 3, 2, colors.modernSteel);
            });
        }

        // é»„æµ¦æ±Ÿ
        function createHuangpuRiver() {
            for (let x = -80; x < 80; x++) {
                for (let z = -5; z < 15; z++) {
                    const wave = Math.sin(x * 0.1) * 0.5;
                    const color = (x + z) % 3 === 0 ? colors.waterLight : colors.water;
                    addVoxel(x, -1 + Math.round(wave), z, color);
                }
            }
        }

        // åœ°é¢å’Œé“è·¯
        function createGround() {
            // é™†å®¶å˜´åœ°é¢
            for (let x = -30; x < 70; x++) {
                for (let z = 15; z < 80; z++) {
                    if (Math.abs(x % 20) < 2 || Math.abs(z % 20) < 2) {
                        addVoxel(x, -1, z, colors.road);
                    } else {
                        addVoxel(x, -1, z, colors.ground);
                    }
                }
            }

            // å¤–æ»©åœ°é¢
            for (let x = -80; x < 0; x++) {
                for (let z = -30; z < -5; z++) {
                    addVoxel(x, -1, z, colors.ground);
                }
            }
        }

        // è£…é¥°æ ‘æœ¨
        function createTrees() {
            const treePositions = [
                [-20, 20], [-15, 25], [-10, 22], [50, 30], [55, 35], [45, 40],
                [20, 60], [25, 55], [60, 50], [65, 45]
            ];

            treePositions.forEach(([tx, tz]) => {
                // æ ‘å¹²
                addCylinder(tx, 0, tz, 1, 4, colors.tree);
                // æ ‘å† 
                addSphere(tx, 6, tz, 3, colors.grass);
            });
        }

        // éœ“è™¹ç¯è£…é¥°
        function createNeonLights() {
            // æ²¿è·¯çš„ç¯
            for (let x = -30; x < 70; x += 10) {
                addVoxel(x, 0, 16, colors.neonYellow);
                addVoxel(x, 1, 16, colors.modernSteel);
                addVoxel(x, 2, 16, colors.modernSteel);
                addVoxel(x, 3, 16, colors.neonYellow);
            }

            // å½©è™¹è£…é¥°
            const neonColors = [colors.neonPink, colors.neonPurple, colors.neonBlue, colors.neonGreen, colors.neonYellow];
            for (let i = 0; i < 5; i++) {
                for (let x = -25; x < -15; x++) {
                    addVoxel(x, 5 + i, -3 + i * 0.5, neonColors[i]);
                }
            }
        }

        // ç”Ÿæˆåœºæ™¯
        loading.textContent = 'ç”Ÿæˆä¸œæ–¹æ˜ç å¡”...';
        setTimeout(() => {
            createOrientalPearlTower(0, 40);
            loading.textContent = 'ç”Ÿæˆä¸Šæµ·ä¸­å¿ƒ...';

            setTimeout(() => {
                createShanghaiTower(25, 50);
                loading.textContent = 'ç”Ÿæˆé‡‘èŒ‚å¤§å¦...';

                setTimeout(() => {
                    createJinMaoTower(45, 45);
                    loading.textContent = 'ç”Ÿæˆç¯çƒé‡‘èä¸­å¿ƒ...';

                    setTimeout(() => {
                        createSWFC(60, 55);
                        loading.textContent = 'ç”Ÿæˆå¤–æ»©å»ºç­‘ç¾¤...';

                        setTimeout(() => {
                            createBundBuildings(-70, -25);
                            loading.textContent = 'ç”Ÿæˆç°ä»£å»ºç­‘ç¾¤...';

                            setTimeout(() => {
                                createModernBuildings(-25, 55);
                                createHuangpuRiver();
                                createGround();
                                createTrees();
                                createNeonLights();

                                loading.textContent = 'åˆå§‹åŒ–æ¸²æŸ“...';
                                setTimeout(() => {
                                    initRender();
                                    loading.style.display = 'none';
                                }, 100);
                            }, 50);
                        }, 50);
                    }, 50);
                }, 50);
            }, 50);
        }, 50);

        // ============ æ¸²æŸ“ç³»ç»Ÿ ============
        let instanceData = null;
        let instanceBuffer = null;
        let colorBuffer = null;
        let voxelCount = 0;

        function initRender() {
            voxelCount = voxels.length;

            // å‡†å¤‡å®ä¾‹æ•°æ®
            const offsets = new Float32Array(voxelCount * 3);
            const colorsData = new Float32Array(voxelCount * 3);

            voxels.forEach((v, i) => {
                offsets[i * 3] = v.x;
                offsets[i * 3 + 1] = v.y;
                offsets[i * 3 + 2] = v.z;
                colorsData[i * 3] = v.color[0];
                colorsData[i * 3 + 1] = v.color[1];
                colorsData[i * 3 + 2] = v.color[2];
            });

            instanceBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, offsets, gl.STATIC_DRAW);

            colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colorsData, gl.STATIC_DRAW);

            // å¼€å§‹åŠ¨ç”»
            animate();
        }

        // çŸ©é˜µå·¥å…·å‡½æ•°
        function createPerspectiveMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ]);
        }

        function createLookAtMatrix(eye, center, up) {
            const zAxis = normalize([eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]]);
            const xAxis = normalize(cross(up, zAxis));
            const yAxis = cross(zAxis, xAxis);

            return new Float32Array([
                xAxis[0], yAxis[0], zAxis[0], 0,
                xAxis[1], yAxis[1], zAxis[1], 0,
                xAxis[2], yAxis[2], zAxis[2], 0,
                -dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1
            ]);
        }

        function createRotationYMatrix(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return new Float32Array([
                c, 0, -s, 0,
                0, 1, 0, 0,
                s, 0, c, 0,
                0, 0, 0, 1
            ]);
        }

        function normalize(v) {
            const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
            return [v[0]/len, v[1]/len, v[2]/len];
        }

        function cross(a, b) {
            return [
                a[1]*b[2] - a[2]*b[1],
                a[2]*b[0] - a[0]*b[2],
                a[0]*b[1] - a[1]*b[0]
            ];
        }

        function dot(a, b) {
            return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
        }

        // ç›¸æœºæ§åˆ¶
        let cameraAngle = 0;
        let cameraHeight = 60;
        let cameraDistance = 180;
        let autoRotate = true;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            autoRotate = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                cameraAngle -= dx * 0.005;
                cameraHeight += dy * 0.5;
                cameraHeight = Math.max(-20, Math.min(150, cameraHeight));
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            cameraDistance += e.deltaY * 0.1;
            cameraDistance = Math.max(50, Math.min(400, cameraDistance));
            e.preventDefault();
        });

        // è§¦æ‘¸æ”¯æŒ
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
                autoRotate = false;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            if (isDragging && e.touches.length === 1) {
                const dx = e.touches[0].clientX - lastMouseX;
                const dy = e.touches[0].clientY - lastMouseY;
                cameraAngle -= dx * 0.005;
                cameraHeight += dy * 0.5;
                cameraHeight = Math.max(-20, Math.min(150, cameraHeight));
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
            }
            e.preventDefault();
        });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });

        // åŠ¨ç”»å¾ªç¯
        let time = 0;
        function animate() {
            time += 0.016;

            if (autoRotate) {
                cameraAngle += 0.003;
            }

            // æ¸…å±
            gl.clearColor(0.05, 0.05, 0.1, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);

            // è®¾ç½®çŸ©é˜µ
            const aspect = canvas.width / canvas.height;
            const projection = createPerspectiveMatrix(Math.PI / 4, aspect, 0.1, 1000);

            const camX = Math.sin(cameraAngle) * cameraDistance + 20;
            const camZ = Math.cos(cameraAngle) * cameraDistance + 40;
            const view = createLookAtMatrix(
                [camX, cameraHeight, camZ],
                [20, 40, 40],
                [0, 1, 0]
            );

            const model = new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);

            gl.uniformMatrix4fv(uProjection, false, projection);
            gl.uniformMatrix4fv(uView, false, view);
            gl.uniformMatrix4fv(uModel, false, model);
            gl.uniform3fv(uLightDir, [0.5, 0.8, 0.3]);
            gl.uniform3fv(uLightDir2, [-0.3, 0.5, -0.5]);
            gl.uniform1f(uTime, time);

            // ç»˜åˆ¶æ‰€æœ‰ä½“ç´ 
            // ç”±äºWebGL1ä¸æ”¯æŒå®ä¾‹åŒ–ï¼Œæˆ‘ä»¬éœ€è¦é€ä¸ªç»˜åˆ¶æˆ–ä½¿ç”¨æ‰©å±•
            // è¿™é‡Œä½¿ç”¨ç®€åŒ–çš„æ‰¹é‡ç»˜åˆ¶æ–¹æ³•

            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBO);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(aNormal);
            gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 24, 12);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeEBO);

            // æ‰¹é‡ç»˜åˆ¶ä½“ç´ 
            for (let i = 0; i < voxelCount; i++) {
                const v = voxels[i];

                // è®¾ç½®åç§»å’Œé¢œè‰²
                gl.disableVertexAttribArray(aOffset);
                gl.vertexAttrib3f(aOffset, v.x, v.y, v.z);
                gl.disableVertexAttribArray(aColor);
                gl.vertexAttrib3fv(aColor, v.color);

                gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            }

            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>
