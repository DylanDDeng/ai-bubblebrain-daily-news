<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D 魔方 - Three.js</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #111; font-family: 'Segoe UI', system-ui, sans-serif; }

#panel {
  position: fixed; top: 20px; left: 20px; width: 232px;
  background: rgba(12,12,30,0.92); backdrop-filter: blur(14px);
  border: 1px solid rgba(255,255,255,0.07); border-radius: 16px;
  padding: 20px 18px; color: #eee; z-index: 10; user-select: none;
}

#panel h2 {
  font-size: 22px; text-align: center; margin-bottom: 2px;
  background: linear-gradient(135deg, #e94560, #0f3460, #e94560);
  background-size: 200% 200%;
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  animation: grad 4s ease infinite;
}
@keyframes grad {
  0%,100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}

.sub { text-align: center; color: #555; font-size: 11px; margin-bottom: 14px; }

.label {
  font-size: 10px; color: #666; text-transform: uppercase;
  letter-spacing: 1.2px; margin: 12px 0 6px;
}

.grid4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; }
.grid3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; margin-top: 4px; }

.b {
  padding: 7px 2px; border: 1px solid rgba(255,255,255,0.06); border-radius: 7px;
  cursor: pointer; font-weight: 600; font-size: 13px; text-align: center;
  background: rgba(255,255,255,0.04); color: #ccc; transition: all .12s;
}
.b:hover { background: rgba(255,255,255,0.12); color: #fff; }
.b:active { transform: scale(0.92); }
.b.r { background: rgba(233,69,96,0.15); border-color: rgba(233,69,96,0.25); color: #e94560; }
.b.r:hover { background: rgba(233,69,96,0.3); }
.b.g { background: rgba(46,204,113,0.12); border-color: rgba(46,204,113,0.2); color: #2ecc71; }
.b.g:hover { background: rgba(46,204,113,0.28); }
.b.bl { background: rgba(52,152,219,0.12); border-color: rgba(52,152,219,0.2); color: #3498db; }
.b.bl:hover { background: rgba(52,152,219,0.28); }

.stats {
  display: flex; justify-content: space-between; font-size: 12px; color: #555;
  margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.05);
}
.stats span { color: #aaa; font-weight: 600; }

.keys {
  margin-top: 10px; font-size: 10px; color: #444; line-height: 1.6; text-align: center;
}
.keys kbd {
  background: rgba(255,255,255,0.06); padding: 1px 5px; border-radius: 3px;
  font-family: monospace; color: #888;
}

#hint {
  position: fixed; bottom: 18px; left: 50%; transform: translateX(-50%);
  color: rgba(255,255,255,0.25); font-size: 12px;
  pointer-events: none; z-index: 10; white-space: nowrap;
}
</style>
</head>
<body>

<div id="panel">
  <h2>3D 魔方</h2>
  <div class="sub">Rubik's Cube Simulator</div>

  <div class="label">面旋转 (顺时针 / 逆时针)</div>
  <div class="grid4">
    <button class="b" onclick="R('U',1)">U</button>
    <button class="b" onclick="R('U',-1)">U'</button>
    <button class="b" onclick="R('D',1)">D</button>
    <button class="b" onclick="R('D',-1)">D'</button>
    <button class="b" onclick="R('R',1)">R</button>
    <button class="b" onclick="R('R',-1)">R'</button>
    <button class="b" onclick="R('L',1)">L</button>
    <button class="b" onclick="R('L',-1)">L'</button>
    <button class="b" onclick="R('F',1)">F</button>
    <button class="b" onclick="R('F',-1)">F'</button>
    <button class="b" onclick="R('B',1)">B</button>
    <button class="b" onclick="R('B',-1)">B'</button>
  </div>

  <div class="label">操作</div>
  <div class="grid3">
    <button class="b r" onclick="doScramble()">打乱</button>
    <button class="b g" onclick="doSolve()">还原</button>
    <button class="b bl" onclick="doReset()">重置</button>
  </div>

  <div class="stats">
    <div>步数: <span id="mc">0</span></div>
    <div>状态: <span id="st">已还原</span></div>
  </div>

  <div class="keys">
    <kbd>U</kbd><kbd>D</kbd><kbd>R</kbd><kbd>L</kbd><kbd>F</kbd><kbd>B</kbd> 旋转
    &nbsp; <kbd>Shift</kbd> 反向<br>
    <kbd>S</kbd> 打乱 &nbsp; <kbd>Z</kbd> 还原
  </div>
</div>

<div id="hint">左键拖动魔方面 → 旋转层 &nbsp;|&nbsp; 右键拖动 → 旋转视角 &nbsp;|&nbsp; 滚轮 → 缩放</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

/* ── Try loading RoundedBoxGeometry, fallback to BoxGeometry ── */
let RoundedBox;
try {
  const m = await import('three/addons/geometries/RoundedBoxGeometry.js');
  RoundedBox = m.RoundedBoxGeometry;
} catch { RoundedBox = null; }

/* ═══════════════════════ Scene ═══════════════════════ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x101020);
scene.fog = new THREE.FogExp2(0x101020, 0.04);

const camera = new THREE.PerspectiveCamera(38, innerWidth / innerHeight, 0.1, 100);
camera.position.set(5.5, 4.2, 5.8);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.15;
document.body.appendChild(renderer.domElement);

/* ── Lights ── */
scene.add(new THREE.AmbientLight(0xffffff, 1.6));
const d1 = new THREE.DirectionalLight(0xffffff, 2.2);
d1.position.set(6, 10, 8);
scene.add(d1);
scene.add(new THREE.DirectionalLight(0x6677aa, 0.6).position.set(-4, -2, -6) && scene.children[scene.children.length - 1] || d1);
const d2 = new THREE.DirectionalLight(0x6677aa, 0.6);
d2.position.set(-4, -2, -6);
scene.add(d2);

/* ── Floor ── */
const floorGeo = new THREE.PlaneGeometry(40, 40);
const floorMat = new THREE.MeshStandardMaterial({ color: 0x0a0a18, roughness: 0.95 });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
floor.position.y = -2.5;
scene.add(floor);

/* ── OrbitControls ── */
const orbit = new OrbitControls(camera, renderer.domElement);
orbit.enableDamping = true;
orbit.dampingFactor = 0.08;
orbit.minDistance = 5;
orbit.maxDistance = 18;
orbit.target.set(0, 0, 0);

/* ═══════════════════════ Cubies ═══════════════════════ */
const cubies = [];
const SIZE = 0.92;
let animating = false;
let history = [];
const pivot = new THREE.Group();
scene.add(pivot);

const GEO = RoundedBox
  ? new RoundedBox(SIZE, SIZE, SIZE, 3, 0.055)
  : new THREE.BoxGeometry(SIZE, SIZE, SIZE);

/* Standard colors: +X Red, -X Orange, +Y White, -Y Yellow, +Z Green, -Z Blue */
const FC = {
  r: 0xC41E3A, o: 0xFF6C00, w: 0xFFFFFF,
  y: 0xFFD500, g: 0x009E60, b: 0x0051BA, x: 0x0e0e0e,
};

function mats(x, y, z) {
  const p = (c) => new THREE.MeshStandardMaterial({ color: c, roughness: 0.28, metalness: 0.0 });
  return [
    p(x === 1 ? FC.r : FC.x), p(x === -1 ? FC.o : FC.x),
    p(y === 1 ? FC.w : FC.x), p(y === -1 ? FC.y : FC.x),
    p(z === 1 ? FC.g : FC.x), p(z === -1 ? FC.b : FC.x),
  ];
}

function buildCube() {
  for (let x = -1; x <= 1; x++)
    for (let y = -1; y <= 1; y++)
      for (let z = -1; z <= 1; z++) {
        const m = new THREE.Mesh(GEO, mats(x, y, z));
        m.position.set(x, y, z);
        scene.add(m);
        cubies.push(m);
      }
}
buildCube();

/* ═══════════════════════ Rotation ═══════════════════════ */
const FACES = {
  U: { ax: 'y', ly: 1, an: -Math.PI / 2 },
  D: { ax: 'y', ly: -1, an: Math.PI / 2 },
  R: { ax: 'x', ly: 1, an: -Math.PI / 2 },
  L: { ax: 'x', ly: -1, an: Math.PI / 2 },
  F: { ax: 'z', ly: 1, an: -Math.PI / 2 },
  B: { ax: 'z', ly: -1, an: Math.PI / 2 },
};

function snap(v) { return Math.round(v); }

function rotateLayer(axis, layer, angle, record = true, ms = 260) {
  return new Promise(res => {
    if (animating) { res(); return; }
    animating = true;

    const sel = cubies.filter(c => snap(c.position[axis]) === layer);
    sel.forEach(c => pivot.attach(c));

    const t0 = performance.now();
    (function tick(now) {
      let t = Math.min((now - t0) / ms, 1);
      t = t < .5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2; // ease
      pivot.rotation[axis] = angle * t;

      if (t < 1) return requestAnimationFrame(tick);

      pivot.rotation[axis] = angle;
      pivot.updateMatrixWorld();
      sel.forEach(c => {
        scene.attach(c);
        c.position.x = snap(c.position.x);
        c.position.y = snap(c.position.y);
        c.position.z = snap(c.position.z);
      });
      pivot.rotation.set(0, 0, 0);
      animating = false;
      if (record) { history.push({ axis, layer, angle }); ui(); }
      res();
    })(performance.now());
  });
}

function ui() {
  document.getElementById('mc').textContent = history.length;
  document.getElementById('st').textContent = history.length ? '已打乱' : '已还原';
}

/* ═══════════════════════ Public API ═══════════════════════ */
window.R = (f, d) => { const v = FACES[f]; if (v) rotateLayer(v.ax, v.ly, v.an * d); };

window.doScramble = async () => {
  if (animating) return;
  history = []; ui();
  const ks = Object.keys(FACES);
  for (let i = 0; i < 25; i++) {
    const f = FACES[ks[Math.random() * 6 | 0]];
    const d = Math.random() > .5 ? 1 : -1;
    await rotateLayer(f.ax, f.ly, f.an * d, true, 80);
  }
};

window.doSolve = async () => {
  if (animating || !history.length) return;
  const moves = history.slice().reverse();
  history = [];
  document.getElementById('st').textContent = '还原中…';
  document.getElementById('mc').textContent = '0';
  for (const m of moves) await rotateLayer(m.axis, m.layer, -m.angle, false, 100);
  document.getElementById('st').textContent = '已还原';
};

window.doReset = () => {
  if (animating) return;
  cubies.forEach(c => { c.parent?.remove(c); c.material.forEach(m => m.dispose()); });
  cubies.length = 0;
  history = [];
  buildCube();
  ui();
};

/* ═══════════════════════ Mouse Drag ═══════════════════════ */
let drag = null;
const rc = new THREE.Raycaster();
const mv = new THREE.Vector2();

renderer.domElement.addEventListener('pointerdown', e => {
  if (animating || e.button !== 0) return;
  mv.set((e.clientX / innerWidth) * 2 - 1, -(e.clientY / innerHeight) * 2 + 1);
  rc.setFromCamera(mv, camera);
  const hits = rc.intersectObjects(cubies);
  if (!hits.length) return;

  const h = hits[0];
  const n = h.face.normal.clone().transformDirection(h.object.matrixWorld);
  n.x = Math.round(n.x); n.y = Math.round(n.y); n.z = Math.round(n.z);
  if (Math.abs(n.x) + Math.abs(n.y) + Math.abs(n.z) !== 1) return;

  drag = { obj: h.object, n, sx: e.clientX, sy: e.clientY, done: false };
  orbit.enabled = false;
});

renderer.domElement.addEventListener('pointermove', e => {
  if (!drag || drag.done || animating) return;
  const dx = e.clientX - drag.sx, dy = e.clientY - drag.sy;
  if (dx * dx + dy * dy < 500) return;
  drag.done = true;

  const cr = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 0);
  const cu = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 1);
  const dw = cr.clone().multiplyScalar(dx).add(cu.clone().multiplyScalar(-dy)).normalize();

  const n = drag.n;
  const proj = dw.clone().sub(n.clone().multiplyScalar(dw.dot(n)));
  if (proj.length() < .01) { orbit.enabled = true; return; }
  proj.normalize();

  const axes = ['x', 'y', 'z'];
  let bestA = null, bestD = 0;
  for (const a of axes) {
    if (Math.abs(n[a]) > .9) continue;
    const v = new THREE.Vector3(); v[a] = 1;
    const d = Math.abs(proj.dot(v));
    if (d > bestD) { bestD = d; bestA = a; }
  }
  if (!bestA) { orbit.enabled = true; return; }

  const dd = new THREE.Vector3(); dd[bestA] = Math.sign(proj[bestA]);
  const rv = new THREE.Vector3().crossVectors(n, dd);
  let ra = 'x', mc = 0;
  for (const a of axes) if (Math.abs(rv[a]) > mc) { mc = Math.abs(rv[a]); ra = a; }

  rotateLayer(ra, snap(drag.obj.position[ra]), Math.sign(rv[ra]) * Math.PI / 2);
  orbit.enabled = true;
});

renderer.domElement.addEventListener('pointerup', () => { drag = null; orbit.enabled = true; });
renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
renderer.domElement.addEventListener('touchstart', e => { if (e.touches.length === 1) e.preventDefault(); }, { passive: false });

/* ═══════════════════════ Keyboard ═══════════════════════ */
document.addEventListener('keydown', e => {
  if (animating) return;
  const k = e.key.toUpperCase();
  if (FACES[k]) window.R(k, e.shiftKey ? -1 : 1);
  else if (k === 'S' && !e.shiftKey) window.doScramble();
  else if (k === 'Z') window.doSolve();
});

/* ═══════════════════════ Render ═══════════════════════ */
(function loop() {
  requestAnimationFrame(loop);
  orbit.update();
  renderer.render(scene, camera);
})();

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
